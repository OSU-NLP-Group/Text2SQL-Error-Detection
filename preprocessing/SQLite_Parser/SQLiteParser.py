# Generated from SQLiteParser.g4 by ANTLR 4.11.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,195,1000,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,1,0,5,0,156,8,0,
        10,0,12,0,159,9,0,1,0,1,0,1,1,5,1,164,8,1,10,1,12,1,167,9,1,1,1,
        1,1,4,1,171,8,1,11,1,12,1,172,1,1,5,1,176,8,1,10,1,12,1,179,9,1,
        1,1,5,1,182,8,1,10,1,12,1,185,9,1,1,2,1,2,1,2,3,2,190,8,2,3,2,192,
        8,2,1,2,1,2,1,3,4,3,197,8,3,11,3,12,3,198,1,3,1,3,1,3,1,3,1,3,1,
        3,1,3,1,3,1,3,1,3,3,3,211,8,3,1,4,3,4,214,8,4,1,4,1,4,1,5,1,5,1,
        5,1,5,1,5,5,5,223,8,5,10,5,12,5,226,9,5,1,5,1,5,3,5,230,8,5,1,5,
        1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,3,6,243,8,6,1,6,1,6,1,6,
        3,6,248,8,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,257,8,6,1,6,1,6,1,6,
        5,6,262,8,6,10,6,12,6,265,9,6,1,6,3,6,268,8,6,1,6,1,6,3,6,272,8,
        6,1,6,3,6,275,8,6,1,6,1,6,1,6,1,6,5,6,281,8,6,10,6,12,6,284,9,6,
        1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,296,8,6,1,6,3,6,299,
        8,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,307,8,6,1,6,1,6,1,6,1,6,1,6,4,6,
        314,8,6,11,6,12,6,315,1,6,1,6,3,6,320,8,6,1,6,1,6,1,6,3,6,325,8,
        6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,
        6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,355,8,6,1,
        6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,367,8,6,1,6,1,6,1,6,3,
        6,372,8,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,384,8,6,1,
        6,1,6,1,6,1,6,3,6,390,8,6,1,6,1,6,1,6,1,6,1,6,3,6,397,8,6,1,6,1,
        6,3,6,401,8,6,1,6,1,6,1,6,1,6,1,6,1,6,5,6,409,8,6,10,6,12,6,412,
        9,6,3,6,414,8,6,1,6,1,6,1,6,1,6,3,6,420,8,6,1,6,1,6,1,6,1,6,3,6,
        426,8,6,1,6,1,6,1,6,1,6,1,6,5,6,433,8,6,10,6,12,6,436,9,6,3,6,438,
        8,6,1,6,1,6,3,6,442,8,6,5,6,444,8,6,10,6,12,6,447,9,6,1,7,1,7,1,
        7,1,7,1,7,1,7,3,7,455,8,7,1,7,1,7,1,8,1,8,1,9,3,9,462,8,9,1,9,1,
        9,1,9,1,9,5,9,468,8,9,10,9,12,9,471,9,9,1,9,3,9,474,8,9,1,9,3,9,
        477,8,9,1,10,1,10,1,10,1,10,3,10,483,8,10,5,10,485,8,10,10,10,12,
        10,488,9,10,1,11,1,11,1,11,5,11,493,8,11,10,11,12,11,496,9,11,1,
        12,1,12,1,12,1,12,5,12,502,8,12,10,12,12,12,505,9,12,1,12,1,12,3,
        12,509,8,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,5,14,518,8,14,10,
        14,12,14,521,9,14,1,14,1,14,3,14,525,8,14,1,15,1,15,3,15,529,8,15,
        1,15,1,15,3,15,533,8,15,1,15,3,15,536,8,15,1,15,3,15,539,8,15,1,
        16,1,16,1,17,3,17,544,8,17,1,17,1,17,3,17,548,8,17,1,17,3,17,551,
        8,17,1,18,3,18,554,8,18,1,18,1,18,1,18,3,18,559,8,18,1,18,1,18,3,
        18,563,8,18,1,18,4,18,566,8,18,11,18,12,18,567,1,18,3,18,571,8,18,
        1,18,3,18,574,8,18,1,19,1,19,1,19,3,19,579,8,19,1,19,1,19,3,19,583,
        8,19,1,19,3,19,586,8,19,1,19,1,19,1,19,1,19,1,19,3,19,593,8,19,1,
        19,1,19,1,19,3,19,598,8,19,1,19,1,19,1,19,1,19,1,19,5,19,605,8,19,
        10,19,12,19,608,9,19,1,19,1,19,3,19,612,8,19,1,19,3,19,615,8,19,
        1,19,1,19,1,19,1,19,5,19,621,8,19,10,19,12,19,624,9,19,1,19,3,19,
        627,8,19,1,19,1,19,1,19,1,19,1,19,1,19,3,19,635,8,19,1,19,3,19,638,
        8,19,3,19,640,8,19,1,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,649,8,
        20,1,20,3,20,652,8,20,3,20,654,8,20,1,21,1,21,3,21,658,8,21,1,21,
        1,21,3,21,662,8,21,1,21,1,21,3,21,666,8,21,1,21,3,21,669,8,21,1,
        22,1,22,1,22,1,22,1,22,1,22,1,22,5,22,678,8,22,10,22,12,22,681,9,
        22,1,22,1,22,3,22,685,8,22,1,23,1,23,3,23,689,8,23,1,23,1,23,3,23,
        693,8,23,1,24,1,24,1,24,1,24,5,24,699,8,24,10,24,12,24,702,9,24,
        1,24,1,24,1,25,1,25,1,25,3,25,709,8,25,1,25,1,25,1,25,3,25,714,8,
        25,1,25,1,25,1,25,1,25,1,25,3,25,721,8,25,1,26,1,26,1,26,1,26,1,
        26,1,26,1,27,1,27,1,27,1,27,3,27,733,8,27,1,27,1,27,1,27,1,27,1,
        27,5,27,740,8,27,10,27,12,27,743,9,27,3,27,745,8,27,1,27,1,27,1,
        27,1,27,1,27,5,27,752,8,27,10,27,12,27,755,9,27,3,27,757,8,27,1,
        27,3,27,760,8,27,1,27,3,27,763,8,27,1,28,1,28,1,28,1,28,1,28,1,28,
        1,28,1,28,3,28,773,8,28,1,29,1,29,1,29,1,29,1,29,1,29,1,29,3,29,
        782,8,29,1,30,1,30,1,30,1,30,1,30,5,30,789,8,30,10,30,12,30,792,
        9,30,1,30,3,30,795,8,30,1,30,1,30,1,31,1,31,1,31,3,31,802,8,31,1,
        31,1,31,1,31,5,31,807,8,31,10,31,12,31,810,9,31,1,31,3,31,813,8,
        31,1,31,1,31,3,31,817,8,31,1,32,1,32,3,32,821,8,32,1,32,1,32,1,32,
        5,32,826,8,32,10,32,12,32,829,9,32,1,33,1,33,1,33,1,33,5,33,835,
        8,33,10,33,12,33,838,9,33,1,34,1,34,1,34,1,34,3,34,844,8,34,1,35,
        1,35,1,35,3,35,849,8,35,1,35,3,35,852,8,35,1,35,1,35,3,35,856,8,
        35,1,36,1,36,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,3,
        37,870,8,37,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,
        38,882,8,38,1,39,1,39,1,39,1,39,1,39,1,39,1,39,3,39,891,8,39,1,40,
        1,40,1,40,1,41,1,41,1,41,1,42,1,42,1,42,4,42,902,8,42,11,42,12,42,
        903,1,43,1,43,1,43,4,43,909,8,43,11,43,12,43,910,1,44,1,44,1,44,
        1,44,1,45,1,45,3,45,919,8,45,1,45,1,45,1,45,3,45,924,8,45,5,45,926,
        8,45,10,45,12,45,929,9,45,1,46,1,46,1,47,1,47,1,48,1,48,1,49,1,49,
        1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,54,1,54,1,55,1,55,1,56,
        1,56,1,57,1,57,1,58,1,58,1,59,1,59,1,60,1,60,1,61,1,61,1,62,1,62,
        1,63,1,63,1,64,1,64,1,65,1,65,1,66,1,66,1,67,1,67,1,68,1,68,1,69,
        1,69,1,70,1,70,1,71,1,71,1,72,1,72,1,73,1,73,1,74,1,74,1,75,1,75,
        1,76,1,76,1,76,1,76,1,76,1,76,1,76,3,76,998,8,76,1,76,1,198,1,12,
        77,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,
        44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,
        88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,
        124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,0,15,
        1,0,8,9,2,0,7,7,12,13,1,0,14,17,1,0,18,21,4,0,77,77,98,98,100,100,
        120,120,3,0,25,25,72,72,128,128,5,0,52,54,105,105,174,175,188,188,
        190,191,2,0,29,29,62,62,3,0,130,130,156,156,181,181,2,0,5,5,107,
        107,1,0,178,179,2,0,34,34,60,60,2,0,8,10,103,103,2,0,187,187,190,
        190,4,0,25,78,80,110,112,125,127,182,1102,0,157,1,0,0,0,2,165,1,
        0,0,0,4,191,1,0,0,0,6,196,1,0,0,0,8,213,1,0,0,0,10,217,1,0,0,0,12,
        324,1,0,0,0,14,448,1,0,0,0,16,458,1,0,0,0,18,461,1,0,0,0,20,478,
        1,0,0,0,22,489,1,0,0,0,24,508,1,0,0,0,26,510,1,0,0,0,28,513,1,0,
        0,0,30,526,1,0,0,0,32,540,1,0,0,0,34,543,1,0,0,0,36,553,1,0,0,0,
        38,639,1,0,0,0,40,653,1,0,0,0,42,668,1,0,0,0,44,684,1,0,0,0,46,692,
        1,0,0,0,48,694,1,0,0,0,50,708,1,0,0,0,52,722,1,0,0,0,54,728,1,0,
        0,0,56,764,1,0,0,0,58,774,1,0,0,0,60,783,1,0,0,0,62,798,1,0,0,0,
        64,818,1,0,0,0,66,830,1,0,0,0,68,839,1,0,0,0,70,845,1,0,0,0,72,857,
        1,0,0,0,74,869,1,0,0,0,76,881,1,0,0,0,78,890,1,0,0,0,80,892,1,0,
        0,0,82,895,1,0,0,0,84,898,1,0,0,0,86,905,1,0,0,0,88,912,1,0,0,0,
        90,916,1,0,0,0,92,930,1,0,0,0,94,932,1,0,0,0,96,934,1,0,0,0,98,936,
        1,0,0,0,100,938,1,0,0,0,102,940,1,0,0,0,104,942,1,0,0,0,106,944,
        1,0,0,0,108,946,1,0,0,0,110,948,1,0,0,0,112,950,1,0,0,0,114,952,
        1,0,0,0,116,954,1,0,0,0,118,956,1,0,0,0,120,958,1,0,0,0,122,960,
        1,0,0,0,124,962,1,0,0,0,126,964,1,0,0,0,128,966,1,0,0,0,130,968,
        1,0,0,0,132,970,1,0,0,0,134,972,1,0,0,0,136,974,1,0,0,0,138,976,
        1,0,0,0,140,978,1,0,0,0,142,980,1,0,0,0,144,982,1,0,0,0,146,984,
        1,0,0,0,148,986,1,0,0,0,150,988,1,0,0,0,152,997,1,0,0,0,154,156,
        3,2,1,0,155,154,1,0,0,0,156,159,1,0,0,0,157,155,1,0,0,0,157,158,
        1,0,0,0,158,160,1,0,0,0,159,157,1,0,0,0,160,161,5,0,0,1,161,1,1,
        0,0,0,162,164,5,1,0,0,163,162,1,0,0,0,164,167,1,0,0,0,165,163,1,
        0,0,0,165,166,1,0,0,0,166,168,1,0,0,0,167,165,1,0,0,0,168,177,3,
        4,2,0,169,171,5,1,0,0,170,169,1,0,0,0,171,172,1,0,0,0,172,170,1,
        0,0,0,172,173,1,0,0,0,173,174,1,0,0,0,174,176,3,4,2,0,175,170,1,
        0,0,0,176,179,1,0,0,0,177,175,1,0,0,0,177,178,1,0,0,0,178,183,1,
        0,0,0,179,177,1,0,0,0,180,182,5,1,0,0,181,180,1,0,0,0,182,185,1,
        0,0,0,183,181,1,0,0,0,183,184,1,0,0,0,184,3,1,0,0,0,185,183,1,0,
        0,0,186,189,5,71,0,0,187,188,5,116,0,0,188,190,5,113,0,0,189,187,
        1,0,0,0,189,190,1,0,0,0,190,192,1,0,0,0,191,186,1,0,0,0,191,192,
        1,0,0,0,192,193,1,0,0,0,193,194,3,18,9,0,194,5,1,0,0,0,195,197,3,
        104,52,0,196,195,1,0,0,0,197,198,1,0,0,0,198,199,1,0,0,0,198,196,
        1,0,0,0,199,210,1,0,0,0,200,201,5,3,0,0,201,202,3,8,4,0,202,203,
        5,4,0,0,203,211,1,0,0,0,204,205,5,3,0,0,205,206,3,8,4,0,206,207,
        5,5,0,0,207,208,3,8,4,0,208,209,5,4,0,0,209,211,1,0,0,0,210,200,
        1,0,0,0,210,204,1,0,0,0,210,211,1,0,0,0,211,7,1,0,0,0,212,214,7,
        0,0,0,213,212,1,0,0,0,213,214,1,0,0,0,214,215,1,0,0,0,215,216,5,
        188,0,0,216,9,1,0,0,0,217,229,3,110,55,0,218,219,5,3,0,0,219,224,
        3,116,58,0,220,221,5,5,0,0,221,223,3,116,58,0,222,220,1,0,0,0,223,
        226,1,0,0,0,224,222,1,0,0,0,224,225,1,0,0,0,225,227,1,0,0,0,226,
        224,1,0,0,0,227,228,5,4,0,0,228,230,1,0,0,0,229,218,1,0,0,0,229,
        230,1,0,0,0,230,231,1,0,0,0,231,232,5,33,0,0,232,233,5,3,0,0,233,
        234,3,18,9,0,234,235,5,4,0,0,235,11,1,0,0,0,236,237,6,6,-1,0,237,
        325,3,16,8,0,238,325,5,189,0,0,239,240,3,108,54,0,240,241,5,2,0,
        0,241,243,1,0,0,0,242,239,1,0,0,0,242,243,1,0,0,0,243,244,1,0,0,
        0,244,245,3,110,55,0,245,246,5,2,0,0,246,248,1,0,0,0,247,242,1,0,
        0,0,247,248,1,0,0,0,248,249,1,0,0,0,249,325,3,116,58,0,250,251,3,
        96,48,0,251,252,3,12,6,21,252,325,1,0,0,0,253,254,3,106,53,0,254,
        267,5,3,0,0,255,257,5,62,0,0,256,255,1,0,0,0,256,257,1,0,0,0,257,
        258,1,0,0,0,258,263,3,12,6,0,259,260,5,5,0,0,260,262,3,12,6,0,261,
        259,1,0,0,0,262,265,1,0,0,0,263,261,1,0,0,0,263,264,1,0,0,0,264,
        268,1,0,0,0,265,263,1,0,0,0,266,268,5,7,0,0,267,256,1,0,0,0,267,
        266,1,0,0,0,267,268,1,0,0,0,268,269,1,0,0,0,269,271,5,4,0,0,270,
        272,3,52,26,0,271,270,1,0,0,0,271,272,1,0,0,0,272,274,1,0,0,0,273,
        275,3,54,27,0,274,273,1,0,0,0,274,275,1,0,0,0,275,325,1,0,0,0,276,
        277,5,3,0,0,277,282,3,12,6,0,278,279,5,5,0,0,279,281,3,12,6,0,280,
        278,1,0,0,0,281,284,1,0,0,0,282,280,1,0,0,0,282,283,1,0,0,0,283,
        285,1,0,0,0,284,282,1,0,0,0,285,286,5,4,0,0,286,325,1,0,0,0,287,
        288,5,43,0,0,288,289,5,3,0,0,289,290,3,12,6,0,290,291,5,33,0,0,291,
        292,3,6,3,0,292,293,5,4,0,0,293,325,1,0,0,0,294,296,5,103,0,0,295,
        294,1,0,0,0,295,296,1,0,0,0,296,297,1,0,0,0,297,299,5,70,0,0,298,
        295,1,0,0,0,298,299,1,0,0,0,299,300,1,0,0,0,300,301,5,3,0,0,301,
        302,3,18,9,0,302,303,5,4,0,0,303,325,1,0,0,0,304,306,5,42,0,0,305,
        307,3,12,6,0,306,305,1,0,0,0,306,307,1,0,0,0,307,313,1,0,0,0,308,
        309,5,149,0,0,309,310,3,12,6,0,310,311,5,137,0,0,311,312,3,12,6,
        0,312,314,1,0,0,0,313,308,1,0,0,0,314,315,1,0,0,0,315,313,1,0,0,
        0,315,316,1,0,0,0,316,319,1,0,0,0,317,318,5,65,0,0,318,320,3,12,
        6,0,319,317,1,0,0,0,319,320,1,0,0,0,320,321,1,0,0,0,321,322,5,66,
        0,0,322,325,1,0,0,0,323,325,3,14,7,0,324,236,1,0,0,0,324,238,1,0,
        0,0,324,247,1,0,0,0,324,250,1,0,0,0,324,253,1,0,0,0,324,276,1,0,
        0,0,324,287,1,0,0,0,324,298,1,0,0,0,324,304,1,0,0,0,324,323,1,0,
        0,0,325,445,1,0,0,0,326,327,10,20,0,0,327,328,5,11,0,0,328,444,3,
        12,6,21,329,330,10,19,0,0,330,331,7,1,0,0,331,444,3,12,6,20,332,
        333,10,18,0,0,333,334,7,0,0,0,334,444,3,12,6,19,335,336,10,17,0,
        0,336,337,7,2,0,0,337,444,3,12,6,18,338,339,10,16,0,0,339,340,7,
        3,0,0,340,444,3,12,6,17,341,354,10,15,0,0,342,355,5,6,0,0,343,355,
        5,22,0,0,344,355,5,23,0,0,345,355,5,24,0,0,346,355,5,93,0,0,347,
        348,5,93,0,0,348,355,5,103,0,0,349,355,5,84,0,0,350,355,5,98,0,0,
        351,355,5,77,0,0,352,355,5,100,0,0,353,355,5,120,0,0,354,342,1,0,
        0,0,354,343,1,0,0,0,354,344,1,0,0,0,354,345,1,0,0,0,354,346,1,0,
        0,0,354,347,1,0,0,0,354,349,1,0,0,0,354,350,1,0,0,0,354,351,1,0,
        0,0,354,352,1,0,0,0,354,353,1,0,0,0,355,356,1,0,0,0,356,444,3,12,
        6,16,357,358,10,14,0,0,358,359,5,32,0,0,359,444,3,12,6,15,360,361,
        10,13,0,0,361,362,5,109,0,0,362,444,3,12,6,14,363,364,10,6,0,0,364,
        366,5,93,0,0,365,367,5,103,0,0,366,365,1,0,0,0,366,367,1,0,0,0,367,
        368,1,0,0,0,368,444,3,12,6,7,369,371,10,5,0,0,370,372,5,103,0,0,
        371,370,1,0,0,0,371,372,1,0,0,0,372,373,1,0,0,0,373,374,5,39,0,0,
        374,375,3,12,6,0,375,376,5,32,0,0,376,377,3,12,6,6,377,444,1,0,0,
        0,378,379,10,9,0,0,379,380,5,45,0,0,380,444,3,118,59,0,381,383,10,
        8,0,0,382,384,5,103,0,0,383,382,1,0,0,0,383,384,1,0,0,0,384,385,
        1,0,0,0,385,386,7,4,0,0,386,389,3,12,6,0,387,388,5,67,0,0,388,390,
        3,12,6,0,389,387,1,0,0,0,389,390,1,0,0,0,390,444,1,0,0,0,391,396,
        10,7,0,0,392,397,5,94,0,0,393,397,5,104,0,0,394,395,5,103,0,0,395,
        397,5,105,0,0,396,392,1,0,0,0,396,393,1,0,0,0,396,394,1,0,0,0,397,
        444,1,0,0,0,398,400,10,4,0,0,399,401,5,103,0,0,400,399,1,0,0,0,400,
        401,1,0,0,0,401,402,1,0,0,0,402,441,5,84,0,0,403,413,5,3,0,0,404,
        414,3,18,9,0,405,410,3,12,6,0,406,407,5,5,0,0,407,409,3,12,6,0,408,
        406,1,0,0,0,409,412,1,0,0,0,410,408,1,0,0,0,410,411,1,0,0,0,411,
        414,1,0,0,0,412,410,1,0,0,0,413,404,1,0,0,0,413,405,1,0,0,0,413,
        414,1,0,0,0,414,415,1,0,0,0,415,442,5,4,0,0,416,417,3,108,54,0,417,
        418,5,2,0,0,418,420,1,0,0,0,419,416,1,0,0,0,419,420,1,0,0,0,420,
        421,1,0,0,0,421,442,3,110,55,0,422,423,3,108,54,0,423,424,5,2,0,
        0,424,426,1,0,0,0,425,422,1,0,0,0,425,426,1,0,0,0,426,427,1,0,0,
        0,427,428,3,150,75,0,428,437,5,3,0,0,429,434,3,12,6,0,430,431,5,
        5,0,0,431,433,3,12,6,0,432,430,1,0,0,0,433,436,1,0,0,0,434,432,1,
        0,0,0,434,435,1,0,0,0,435,438,1,0,0,0,436,434,1,0,0,0,437,429,1,
        0,0,0,437,438,1,0,0,0,438,439,1,0,0,0,439,440,5,4,0,0,440,442,1,
        0,0,0,441,403,1,0,0,0,441,419,1,0,0,0,441,425,1,0,0,0,442,444,1,
        0,0,0,443,326,1,0,0,0,443,329,1,0,0,0,443,332,1,0,0,0,443,335,1,
        0,0,0,443,338,1,0,0,0,443,341,1,0,0,0,443,357,1,0,0,0,443,360,1,
        0,0,0,443,363,1,0,0,0,443,369,1,0,0,0,443,378,1,0,0,0,443,381,1,
        0,0,0,443,391,1,0,0,0,443,398,1,0,0,0,444,447,1,0,0,0,445,443,1,
        0,0,0,445,446,1,0,0,0,446,13,1,0,0,0,447,445,1,0,0,0,448,449,5,117,
        0,0,449,454,5,3,0,0,450,455,5,82,0,0,451,452,7,5,0,0,452,453,5,5,
        0,0,453,455,3,98,49,0,454,450,1,0,0,0,454,451,1,0,0,0,455,456,1,
        0,0,0,456,457,5,4,0,0,457,15,1,0,0,0,458,459,7,6,0,0,459,17,1,0,
        0,0,460,462,3,64,32,0,461,460,1,0,0,0,461,462,1,0,0,0,462,463,1,
        0,0,0,463,469,3,30,15,0,464,465,3,46,23,0,465,466,3,30,15,0,466,
        468,1,0,0,0,467,464,1,0,0,0,468,471,1,0,0,0,469,467,1,0,0,0,469,
        470,1,0,0,0,470,473,1,0,0,0,471,469,1,0,0,0,472,474,3,66,33,0,473,
        472,1,0,0,0,473,474,1,0,0,0,474,476,1,0,0,0,475,477,3,68,34,0,476,
        475,1,0,0,0,476,477,1,0,0,0,477,19,1,0,0,0,478,486,3,38,19,0,479,
        480,3,42,21,0,480,482,3,38,19,0,481,483,3,44,22,0,482,481,1,0,0,
        0,482,483,1,0,0,0,483,485,1,0,0,0,484,479,1,0,0,0,485,488,1,0,0,
        0,486,484,1,0,0,0,486,487,1,0,0,0,487,21,1,0,0,0,488,486,1,0,0,0,
        489,494,3,40,20,0,490,491,5,5,0,0,491,493,3,40,20,0,492,490,1,0,
        0,0,493,496,1,0,0,0,494,492,1,0,0,0,494,495,1,0,0,0,495,23,1,0,0,
        0,496,494,1,0,0,0,497,498,5,75,0,0,498,503,3,38,19,0,499,500,5,5,
        0,0,500,502,3,38,19,0,501,499,1,0,0,0,502,505,1,0,0,0,503,501,1,
        0,0,0,503,504,1,0,0,0,504,509,1,0,0,0,505,503,1,0,0,0,506,507,5,
        75,0,0,507,509,3,20,10,0,508,497,1,0,0,0,508,506,1,0,0,0,509,25,
        1,0,0,0,510,511,5,150,0,0,511,512,3,12,6,0,512,27,1,0,0,0,513,514,
        5,79,0,0,514,519,3,12,6,0,515,516,5,5,0,0,516,518,3,12,6,0,517,515,
        1,0,0,0,518,521,1,0,0,0,519,517,1,0,0,0,519,520,1,0,0,0,520,524,
        1,0,0,0,521,519,1,0,0,0,522,523,5,80,0,0,523,525,3,12,6,0,524,522,
        1,0,0,0,524,525,1,0,0,0,525,29,1,0,0,0,526,528,5,132,0,0,527,529,
        7,7,0,0,528,527,1,0,0,0,528,529,1,0,0,0,529,530,1,0,0,0,530,532,
        3,22,11,0,531,533,3,24,12,0,532,531,1,0,0,0,532,533,1,0,0,0,533,
        535,1,0,0,0,534,536,3,26,13,0,535,534,1,0,0,0,535,536,1,0,0,0,536,
        538,1,0,0,0,537,539,3,28,14,0,538,537,1,0,0,0,538,539,1,0,0,0,539,
        31,1,0,0,0,540,541,3,18,9,0,541,33,1,0,0,0,542,544,3,64,32,0,543,
        542,1,0,0,0,543,544,1,0,0,0,544,545,1,0,0,0,545,547,3,30,15,0,546,
        548,3,66,33,0,547,546,1,0,0,0,547,548,1,0,0,0,548,550,1,0,0,0,549,
        551,3,68,34,0,550,549,1,0,0,0,550,551,1,0,0,0,551,35,1,0,0,0,552,
        554,3,64,32,0,553,552,1,0,0,0,553,554,1,0,0,0,554,555,1,0,0,0,555,
        565,3,30,15,0,556,558,5,141,0,0,557,559,5,29,0,0,558,557,1,0,0,0,
        558,559,1,0,0,0,559,563,1,0,0,0,560,563,5,91,0,0,561,563,5,68,0,
        0,562,556,1,0,0,0,562,560,1,0,0,0,562,561,1,0,0,0,563,564,1,0,0,
        0,564,566,3,30,15,0,565,562,1,0,0,0,566,567,1,0,0,0,567,565,1,0,
        0,0,567,568,1,0,0,0,568,570,1,0,0,0,569,571,3,66,33,0,570,569,1,
        0,0,0,570,571,1,0,0,0,571,573,1,0,0,0,572,574,3,68,34,0,573,572,
        1,0,0,0,573,574,1,0,0,0,574,37,1,0,0,0,575,576,3,108,54,0,576,577,
        5,2,0,0,577,579,1,0,0,0,578,575,1,0,0,0,578,579,1,0,0,0,579,580,
        1,0,0,0,580,585,3,110,55,0,581,583,5,33,0,0,582,581,1,0,0,0,582,
        583,1,0,0,0,583,584,1,0,0,0,584,586,3,134,67,0,585,582,1,0,0,0,585,
        586,1,0,0,0,586,592,1,0,0,0,587,588,5,86,0,0,588,589,5,40,0,0,589,
        593,3,122,61,0,590,591,5,103,0,0,591,593,5,86,0,0,592,587,1,0,0,
        0,592,590,1,0,0,0,592,593,1,0,0,0,593,640,1,0,0,0,594,595,3,108,
        54,0,595,596,5,2,0,0,596,598,1,0,0,0,597,594,1,0,0,0,597,598,1,0,
        0,0,598,599,1,0,0,0,599,600,3,150,75,0,600,601,5,3,0,0,601,606,3,
        12,6,0,602,603,5,5,0,0,603,605,3,12,6,0,604,602,1,0,0,0,605,608,
        1,0,0,0,606,604,1,0,0,0,606,607,1,0,0,0,607,609,1,0,0,0,608,606,
        1,0,0,0,609,614,5,4,0,0,610,612,5,33,0,0,611,610,1,0,0,0,611,612,
        1,0,0,0,612,613,1,0,0,0,613,615,3,134,67,0,614,611,1,0,0,0,614,615,
        1,0,0,0,615,640,1,0,0,0,616,626,5,3,0,0,617,622,3,38,19,0,618,619,
        5,5,0,0,619,621,3,38,19,0,620,618,1,0,0,0,621,624,1,0,0,0,622,620,
        1,0,0,0,622,623,1,0,0,0,623,627,1,0,0,0,624,622,1,0,0,0,625,627,
        3,20,10,0,626,617,1,0,0,0,626,625,1,0,0,0,627,628,1,0,0,0,628,629,
        5,4,0,0,629,640,1,0,0,0,630,631,5,3,0,0,631,632,3,18,9,0,632,637,
        5,4,0,0,633,635,5,33,0,0,634,633,1,0,0,0,634,635,1,0,0,0,635,636,
        1,0,0,0,636,638,3,134,67,0,637,634,1,0,0,0,637,638,1,0,0,0,638,640,
        1,0,0,0,639,578,1,0,0,0,639,597,1,0,0,0,639,616,1,0,0,0,639,630,
        1,0,0,0,640,39,1,0,0,0,641,654,5,7,0,0,642,643,3,110,55,0,643,644,
        5,2,0,0,644,645,5,7,0,0,645,654,1,0,0,0,646,651,3,12,6,0,647,649,
        5,33,0,0,648,647,1,0,0,0,648,649,1,0,0,0,649,650,1,0,0,0,650,652,
        3,100,50,0,651,648,1,0,0,0,651,652,1,0,0,0,652,654,1,0,0,0,653,641,
        1,0,0,0,653,642,1,0,0,0,653,646,1,0,0,0,654,41,1,0,0,0,655,669,5,
        5,0,0,656,658,5,101,0,0,657,656,1,0,0,0,657,658,1,0,0,0,658,665,
        1,0,0,0,659,661,5,97,0,0,660,662,5,112,0,0,661,660,1,0,0,0,661,662,
        1,0,0,0,662,666,1,0,0,0,663,666,5,88,0,0,664,666,5,51,0,0,665,659,
        1,0,0,0,665,663,1,0,0,0,665,664,1,0,0,0,665,666,1,0,0,0,666,667,
        1,0,0,0,667,669,5,95,0,0,668,655,1,0,0,0,668,657,1,0,0,0,669,43,
        1,0,0,0,670,671,5,108,0,0,671,685,3,12,6,0,672,673,5,144,0,0,673,
        674,5,3,0,0,674,679,3,116,58,0,675,676,5,5,0,0,676,678,3,116,58,
        0,677,675,1,0,0,0,678,681,1,0,0,0,679,677,1,0,0,0,679,680,1,0,0,
        0,680,682,1,0,0,0,681,679,1,0,0,0,682,683,5,4,0,0,683,685,1,0,0,
        0,684,670,1,0,0,0,684,672,1,0,0,0,685,45,1,0,0,0,686,688,5,141,0,
        0,687,689,5,29,0,0,688,687,1,0,0,0,688,689,1,0,0,0,689,693,1,0,0,
        0,690,693,5,91,0,0,691,693,5,68,0,0,692,686,1,0,0,0,692,690,1,0,
        0,0,692,691,1,0,0,0,693,47,1,0,0,0,694,695,5,3,0,0,695,700,3,116,
        58,0,696,697,5,5,0,0,697,699,3,116,58,0,698,696,1,0,0,0,699,702,
        1,0,0,0,700,698,1,0,0,0,700,701,1,0,0,0,701,703,1,0,0,0,702,700,
        1,0,0,0,703,704,5,4,0,0,704,49,1,0,0,0,705,706,3,108,54,0,706,707,
        5,2,0,0,707,709,1,0,0,0,708,705,1,0,0,0,708,709,1,0,0,0,709,710,
        1,0,0,0,710,713,3,110,55,0,711,712,5,33,0,0,712,714,3,140,70,0,713,
        711,1,0,0,0,713,714,1,0,0,0,714,720,1,0,0,0,715,716,5,86,0,0,716,
        717,5,40,0,0,717,721,3,122,61,0,718,719,5,103,0,0,719,721,5,86,0,
        0,720,715,1,0,0,0,720,718,1,0,0,0,720,721,1,0,0,0,721,51,1,0,0,0,
        722,723,5,180,0,0,723,724,5,3,0,0,724,725,5,150,0,0,725,726,3,12,
        6,0,726,727,5,4,0,0,727,53,1,0,0,0,728,762,5,154,0,0,729,763,3,138,
        69,0,730,732,5,3,0,0,731,733,3,144,72,0,732,731,1,0,0,0,732,733,
        1,0,0,0,733,744,1,0,0,0,734,735,5,155,0,0,735,736,5,40,0,0,736,741,
        3,12,6,0,737,738,5,5,0,0,738,740,3,12,6,0,739,737,1,0,0,0,740,743,
        1,0,0,0,741,739,1,0,0,0,741,742,1,0,0,0,742,745,1,0,0,0,743,741,
        1,0,0,0,744,734,1,0,0,0,744,745,1,0,0,0,745,756,1,0,0,0,746,747,
        5,110,0,0,747,748,5,40,0,0,748,753,3,70,35,0,749,750,5,5,0,0,750,
        752,3,70,35,0,751,749,1,0,0,0,752,755,1,0,0,0,753,751,1,0,0,0,753,
        754,1,0,0,0,754,757,1,0,0,0,755,753,1,0,0,0,756,746,1,0,0,0,756,
        757,1,0,0,0,757,759,1,0,0,0,758,760,3,56,28,0,759,758,1,0,0,0,759,
        760,1,0,0,0,760,761,1,0,0,0,761,763,5,4,0,0,762,729,1,0,0,0,762,
        730,1,0,0,0,763,55,1,0,0,0,764,772,3,58,29,0,765,766,5,182,0,0,766,
        767,5,102,0,0,767,773,5,184,0,0,768,769,5,159,0,0,769,773,5,129,
        0,0,770,773,5,78,0,0,771,773,5,183,0,0,772,765,1,0,0,0,772,768,1,
        0,0,0,772,770,1,0,0,0,772,771,1,0,0,0,772,773,1,0,0,0,773,57,1,0,
        0,0,774,781,7,8,0,0,775,782,3,78,39,0,776,777,5,39,0,0,777,778,3,
        74,37,0,778,779,5,32,0,0,779,780,3,76,38,0,780,782,1,0,0,0,781,775,
        1,0,0,0,781,776,1,0,0,0,782,59,1,0,0,0,783,784,3,146,73,0,784,794,
        5,3,0,0,785,790,3,12,6,0,786,787,5,5,0,0,787,789,3,12,6,0,788,786,
        1,0,0,0,789,792,1,0,0,0,790,788,1,0,0,0,790,791,1,0,0,0,791,795,
        1,0,0,0,792,790,1,0,0,0,793,795,5,7,0,0,794,785,1,0,0,0,794,793,
        1,0,0,0,795,796,1,0,0,0,796,797,5,4,0,0,797,61,1,0,0,0,798,799,3,
        148,74,0,799,812,5,3,0,0,800,802,5,62,0,0,801,800,1,0,0,0,801,802,
        1,0,0,0,802,803,1,0,0,0,803,808,3,12,6,0,804,805,5,5,0,0,805,807,
        3,12,6,0,806,804,1,0,0,0,807,810,1,0,0,0,808,806,1,0,0,0,808,809,
        1,0,0,0,809,813,1,0,0,0,810,808,1,0,0,0,811,813,5,7,0,0,812,801,
        1,0,0,0,812,811,1,0,0,0,812,813,1,0,0,0,813,814,1,0,0,0,814,816,
        5,4,0,0,815,817,3,52,26,0,816,815,1,0,0,0,816,817,1,0,0,0,817,63,
        1,0,0,0,818,820,5,151,0,0,819,821,5,118,0,0,820,819,1,0,0,0,820,
        821,1,0,0,0,821,822,1,0,0,0,822,827,3,10,5,0,823,824,5,5,0,0,824,
        826,3,10,5,0,825,823,1,0,0,0,826,829,1,0,0,0,827,825,1,0,0,0,827,
        828,1,0,0,0,828,65,1,0,0,0,829,827,1,0,0,0,830,831,5,111,0,0,831,
        836,3,70,35,0,832,833,5,5,0,0,833,835,3,70,35,0,834,832,1,0,0,0,
        835,838,1,0,0,0,836,834,1,0,0,0,836,837,1,0,0,0,837,67,1,0,0,0,838,
        836,1,0,0,0,839,840,5,99,0,0,840,843,3,12,6,0,841,842,7,9,0,0,842,
        844,3,12,6,0,843,841,1,0,0,0,843,844,1,0,0,0,844,69,1,0,0,0,845,
        848,3,12,6,0,846,847,5,45,0,0,847,849,3,118,59,0,848,846,1,0,0,0,
        848,849,1,0,0,0,849,851,1,0,0,0,850,852,3,72,36,0,851,850,1,0,0,
        0,851,852,1,0,0,0,852,855,1,0,0,0,853,854,5,177,0,0,854,856,7,10,
        0,0,855,853,1,0,0,0,855,856,1,0,0,0,856,71,1,0,0,0,857,858,7,11,
        0,0,858,73,1,0,0,0,859,860,3,12,6,0,860,861,5,157,0,0,861,870,1,
        0,0,0,862,863,3,12,6,0,863,864,5,160,0,0,864,870,1,0,0,0,865,866,
        5,159,0,0,866,870,5,129,0,0,867,868,5,158,0,0,868,870,5,157,0,0,
        869,859,1,0,0,0,869,862,1,0,0,0,869,865,1,0,0,0,869,867,1,0,0,0,
        870,75,1,0,0,0,871,872,3,12,6,0,872,873,5,157,0,0,873,882,1,0,0,
        0,874,875,3,12,6,0,875,876,5,160,0,0,876,882,1,0,0,0,877,878,5,159,
        0,0,878,882,5,129,0,0,879,880,5,158,0,0,880,882,5,160,0,0,881,871,
        1,0,0,0,881,874,1,0,0,0,881,877,1,0,0,0,881,879,1,0,0,0,882,77,1,
        0,0,0,883,884,3,12,6,0,884,885,5,157,0,0,885,891,1,0,0,0,886,887,
        5,158,0,0,887,891,5,157,0,0,888,889,5,159,0,0,889,891,5,129,0,0,
        890,883,1,0,0,0,890,886,1,0,0,0,890,888,1,0,0,0,891,79,1,0,0,0,892,
        893,5,5,0,0,893,894,3,8,4,0,894,81,1,0,0,0,895,896,5,5,0,0,896,897,
        3,8,4,0,897,83,1,0,0,0,898,899,5,155,0,0,899,901,5,40,0,0,900,902,
        3,12,6,0,901,900,1,0,0,0,902,903,1,0,0,0,903,901,1,0,0,0,903,904,
        1,0,0,0,904,85,1,0,0,0,905,906,5,110,0,0,906,908,5,40,0,0,907,909,
        3,12,6,0,908,907,1,0,0,0,909,910,1,0,0,0,910,908,1,0,0,0,910,911,
        1,0,0,0,911,87,1,0,0,0,912,913,5,110,0,0,913,914,5,40,0,0,914,915,
        3,90,45,0,915,89,1,0,0,0,916,918,3,12,6,0,917,919,3,72,36,0,918,
        917,1,0,0,0,918,919,1,0,0,0,919,927,1,0,0,0,920,921,5,5,0,0,921,
        923,3,12,6,0,922,924,3,72,36,0,923,922,1,0,0,0,923,924,1,0,0,0,924,
        926,1,0,0,0,925,920,1,0,0,0,926,929,1,0,0,0,927,925,1,0,0,0,927,
        928,1,0,0,0,928,91,1,0,0,0,929,927,1,0,0,0,930,931,3,18,9,0,931,
        93,1,0,0,0,932,933,3,18,9,0,933,95,1,0,0,0,934,935,7,12,0,0,935,
        97,1,0,0,0,936,937,5,190,0,0,937,99,1,0,0,0,938,939,7,13,0,0,939,
        101,1,0,0,0,940,941,7,14,0,0,941,103,1,0,0,0,942,943,3,152,76,0,
        943,105,1,0,0,0,944,945,3,152,76,0,945,107,1,0,0,0,946,947,3,152,
        76,0,947,109,1,0,0,0,948,949,3,152,76,0,949,111,1,0,0,0,950,951,
        3,152,76,0,951,113,1,0,0,0,952,953,3,152,76,0,953,115,1,0,0,0,954,
        955,3,152,76,0,955,117,1,0,0,0,956,957,3,152,76,0,957,119,1,0,0,
        0,958,959,3,152,76,0,959,121,1,0,0,0,960,961,3,152,76,0,961,123,
        1,0,0,0,962,963,3,152,76,0,963,125,1,0,0,0,964,965,3,152,76,0,965,
        127,1,0,0,0,966,967,3,152,76,0,967,129,1,0,0,0,968,969,3,152,76,
        0,969,131,1,0,0,0,970,971,3,152,76,0,971,133,1,0,0,0,972,973,3,152,
        76,0,973,135,1,0,0,0,974,975,3,152,76,0,975,137,1,0,0,0,976,977,
        3,152,76,0,977,139,1,0,0,0,978,979,3,152,76,0,979,141,1,0,0,0,980,
        981,3,152,76,0,981,143,1,0,0,0,982,983,3,152,76,0,983,145,1,0,0,
        0,984,985,3,152,76,0,985,147,1,0,0,0,986,987,3,152,76,0,987,149,
        1,0,0,0,988,989,3,152,76,0,989,151,1,0,0,0,990,998,5,187,0,0,991,
        998,3,102,51,0,992,998,5,190,0,0,993,994,5,3,0,0,994,995,3,152,76,
        0,995,996,5,4,0,0,996,998,1,0,0,0,997,990,1,0,0,0,997,991,1,0,0,
        0,997,992,1,0,0,0,997,993,1,0,0,0,998,153,1,0,0,0,126,157,165,172,
        177,183,189,191,198,210,213,224,229,242,247,256,263,267,271,274,
        282,295,298,306,315,319,324,354,366,371,383,389,396,400,410,413,
        419,425,434,437,441,443,445,454,461,469,473,476,482,486,494,503,
        508,519,524,528,532,535,538,543,547,550,553,558,562,567,570,573,
        578,582,585,592,597,606,611,614,622,626,634,637,639,648,651,653,
        657,661,665,668,679,684,688,692,700,708,713,720,732,741,744,753,
        756,759,762,772,781,790,794,801,808,812,816,820,827,836,843,848,
        851,855,869,881,890,903,910,918,923,927,997
    ]

class SQLiteParser ( Parser ):

    grammarFileName = "SQLiteParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "'.'", "'('", "')'", "','", "'='", 
                     "'*'", "'+'", "'-'", "'~'", "'||'", "'/'", "'%'", "'<<'", 
                     "'>>'", "'&'", "'|'", "'<'", "'<='", "'>'", "'>='", 
                     "'=='", "'!='", "'<>'", "'ABORT'", "'ACTION'", "'ADD'", 
                     "'AFTER'", "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", 
                     "'AS'", "'ASC'", "'ATTACH'", "'AUTOINCREMENT'", "'BEFORE'", 
                     "'BEGIN'", "'BETWEEN'", "'BY'", "'CASCADE'", "'CASE'", 
                     "'CAST'", "'CHECK'", "'COLLATE'", "'COLUMN'", "'COMMIT'", 
                     "'CONFLICT'", "'CONSTRAINT'", "'CREATE'", "'CROSS'", 
                     "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", 
                     "'DATABASE'", "'DEFAULT'", "'DEFERRABLE'", "'DEFERRED'", 
                     "'DELETE'", "'DESC'", "'DETACH'", "'DISTINCT'", "'DROP'", 
                     "'EACH'", "'ELSE'", "'END'", "'ESCAPE'", "'EXCEPT'", 
                     "'EXCLUSIVE'", "'EXISTS'", "'EXPLAIN'", "'FAIL'", "'FOR'", 
                     "'FOREIGN'", "'FROM'", "'FULL'", "'GLOB'", "'GROUP'", 
                     "'GROUP BY'", "'HAVING'", "'IF'", "'IGNORE'", "'IMMEDIATE'", 
                     "'IN'", "'INDEX'", "'INDEXED'", "'INITIALLY'", "'INNER'", 
                     "'INSERT'", "'INSTEAD'", "'INTERSECT'", "'INTO'", "'IS'", 
                     "'ISNULL'", "'JOIN'", "'KEY'", "'LEFT'", "'LIKE'", 
                     "'LIMIT'", "'MATCH'", "'NATURAL'", "'NO'", "'NOT'", 
                     "'NOTNULL'", "'NULL'", "'OF'", "'OFFSET'", "'ON'", 
                     "'OR'", "'ORDER'", "'ORDER BY'", "'OUTER'", "'PLAN'", 
                     "'PRAGMA'", "'PRIMARY'", "'QUERY'", "'RAISE'", "'RECURSIVE'", 
                     "'REFERENCES'", "'REGEXP'", "'REINDEX'", "'RELEASE'", 
                     "'RENAME'", "'REPLACE'", "'RESTRICT'", "'RETURNING'", 
                     "'RIGHT'", "'ROLLBACK'", "'ROW'", "'ROWS'", "'SAVEPOINT'", 
                     "'SELECT'", "'SET'", "'TABLE'", "'TEMP'", "'TEMPORARY'", 
                     "'THEN'", "'TO'", "'TRANSACTION'", "'TRIGGER'", "'UNION'", 
                     "'UNIQUE'", "'UPDATE'", "'USING'", "'VACUUM'", "'VALUES'", 
                     "'VIEW'", "'VIRTUAL'", "'WHEN'", "'WHERE'", "'WITH'", 
                     "'WITHOUT'", "'FIRST_VALUE'", "'OVER'", "'PARTITION'", 
                     "'RANGE'", "'PRECEDING'", "'UNBOUNDED'", "'CURRENT'", 
                     "'FOLLOWING'", "'CUME_DIST'", "'DENSE_RANK'", "'LAG'", 
                     "'LAST_VALUE'", "'LEAD'", "'NTH_VALUE'", "'NTILE'", 
                     "'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'", "'GENERATED'", 
                     "'ALWAYS'", "'STORED'", "'TRUE'", "'FALSE'", "'WINDOW'", 
                     "'NULLS'", "'FIRST'", "'LAST'", "'FILTER'", "'GROUPS'", 
                     "'EXCLUDE'", "'TIES'", "'OTHERS'", "'DO'", "'NOTHING'" ]

    symbolicNames = [ "<INVALID>", "SCOL", "DOT", "OPEN_PAR", "CLOSE_PAR", 
                      "COMMA", "ASSIGN", "STAR", "PLUS", "MINUS", "TILDE", 
                      "PIPE2", "DIV", "MOD", "LT2", "GT2", "AMP", "PIPE", 
                      "LT", "LT_EQ", "GT", "GT_EQ", "EQ", "NOT_EQ1", "NOT_EQ2", 
                      "ABORT_", "ACTION_", "ADD_", "AFTER_", "ALL_", "ALTER_", 
                      "ANALYZE_", "AND_", "AS_", "ASC_", "ATTACH_", "AUTOINCREMENT_", 
                      "BEFORE_", "BEGIN_", "BETWEEN_", "BY_", "CASCADE_", 
                      "CASE_", "CAST_", "CHECK_", "COLLATE_", "COLUMN_", 
                      "COMMIT_", "CONFLICT_", "CONSTRAINT_", "CREATE_", 
                      "CROSS_", "CURRENT_DATE_", "CURRENT_TIME_", "CURRENT_TIMESTAMP_", 
                      "DATABASE_", "DEFAULT_", "DEFERRABLE_", "DEFERRED_", 
                      "DELETE_", "DESC_", "DETACH_", "DISTINCT_", "DROP_", 
                      "EACH_", "ELSE_", "END_", "ESCAPE_", "EXCEPT_", "EXCLUSIVE_", 
                      "EXISTS_", "EXPLAIN_", "FAIL_", "FOR_", "FOREIGN_", 
                      "FROM_", "FULL_", "GLOB_", "GROUP_", "GROUP_BY_", 
                      "HAVING_", "IF_", "IGNORE_", "IMMEDIATE_", "IN_", 
                      "INDEX_", "INDEXED_", "INITIALLY_", "INNER_", "INSERT_", 
                      "INSTEAD_", "INTERSECT_", "INTO_", "IS_", "ISNULL_", 
                      "JOIN_", "KEY_", "LEFT_", "LIKE_", "LIMIT_", "MATCH_", 
                      "NATURAL_", "NO_", "NOT_", "NOTNULL_", "NULL_", "OF_", 
                      "OFFSET_", "ON_", "OR_", "ORDER_", "ORDER_BY_", "OUTER_", 
                      "PLAN_", "PRAGMA_", "PRIMARY_", "QUERY_", "RAISE_", 
                      "RECURSIVE_", "REFERENCES_", "REGEXP_", "REINDEX_", 
                      "RELEASE_", "RENAME_", "REPLACE_", "RESTRICT_", "RETURNING_", 
                      "RIGHT_", "ROLLBACK_", "ROW_", "ROWS_", "SAVEPOINT_", 
                      "SELECT_", "SET_", "TABLE_", "TEMP_", "TEMPORARY_", 
                      "THEN_", "TO_", "TRANSACTION_", "TRIGGER_", "UNION_", 
                      "UNIQUE_", "UPDATE_", "USING_", "VACUUM_", "VALUES_", 
                      "VIEW_", "VIRTUAL_", "WHEN_", "WHERE_", "WITH_", "WITHOUT_", 
                      "FIRST_VALUE_", "OVER_", "PARTITION_", "RANGE_", "PRECEDING_", 
                      "UNBOUNDED_", "CURRENT_", "FOLLOWING_", "CUME_DIST_", 
                      "DENSE_RANK_", "LAG_", "LAST_VALUE_", "LEAD_", "NTH_VALUE_", 
                      "NTILE_", "PERCENT_RANK_", "RANK_", "ROW_NUMBER_", 
                      "GENERATED_", "ALWAYS_", "STORED_", "TRUE_", "FALSE_", 
                      "WINDOW_", "NULLS_", "FIRST_", "LAST_", "FILTER_", 
                      "GROUPS_", "EXCLUDE_", "TIES_", "OTHERS_", "DO_", 
                      "NOTHING_", "IDENTIFIER", "NUMERIC_LITERAL", "BIND_PARAMETER", 
                      "STRING_LITERAL", "BLOB_LITERAL", "SINGLE_LINE_COMMENT", 
                      "MULTILINE_COMMENT", "SPACES", "UNEXPECTED_CHAR" ]

    RULE_parse = 0
    RULE_sql_stmt_list = 1
    RULE_sql_stmt = 2
    RULE_type_name = 3
    RULE_signed_number = 4
    RULE_common_table_expression = 5
    RULE_expr = 6
    RULE_raise_function = 7
    RULE_literal_value = 8
    RULE_select_stmt = 9
    RULE_join_clause = 10
    RULE_result_clause = 11
    RULE_from_clause = 12
    RULE_where_clause = 13
    RULE_group_by_clause = 14
    RULE_select_core = 15
    RULE_factored_select_stmt = 16
    RULE_simple_select_stmt = 17
    RULE_compound_select_stmt = 18
    RULE_table_or_subquery = 19
    RULE_result_column = 20
    RULE_join_operator = 21
    RULE_join_constraint = 22
    RULE_compound_operator = 23
    RULE_column_name_list = 24
    RULE_qualified_table_name = 25
    RULE_filter_clause = 26
    RULE_over_clause = 27
    RULE_frame_spec = 28
    RULE_frame_clause = 29
    RULE_simple_function_invocation = 30
    RULE_aggregate_function_invocation = 31
    RULE_common_table_stmt = 32
    RULE_order_by_stmt = 33
    RULE_limit_stmt = 34
    RULE_ordering_term = 35
    RULE_asc_desc = 36
    RULE_frame_left = 37
    RULE_frame_right = 38
    RULE_frame_single = 39
    RULE_offset = 40
    RULE_default_value = 41
    RULE_partition_by = 42
    RULE_order_by_expr = 43
    RULE_order_by_expr_asc_desc = 44
    RULE_expr_asc_desc = 45
    RULE_initial_select = 46
    RULE_recursive_select = 47
    RULE_unary_operator = 48
    RULE_error_message = 49
    RULE_column_alias = 50
    RULE_keyword = 51
    RULE_name = 52
    RULE_function_name = 53
    RULE_schema_name = 54
    RULE_table_name = 55
    RULE_table_or_index_name = 56
    RULE_new_table_name = 57
    RULE_column_name = 58
    RULE_collation_name = 59
    RULE_foreign_table = 60
    RULE_index_name = 61
    RULE_trigger_name = 62
    RULE_view_name = 63
    RULE_module_name = 64
    RULE_pragma_name = 65
    RULE_savepoint_name = 66
    RULE_table_alias = 67
    RULE_transaction_name = 68
    RULE_window_name = 69
    RULE_alias = 70
    RULE_filename = 71
    RULE_base_window_name = 72
    RULE_simple_func = 73
    RULE_aggregate_func = 74
    RULE_table_function_name = 75
    RULE_any_name = 76

    ruleNames =  [ "parse", "sql_stmt_list", "sql_stmt", "type_name", "signed_number", 
                   "common_table_expression", "expr", "raise_function", 
                   "literal_value", "select_stmt", "join_clause", "result_clause", 
                   "from_clause", "where_clause", "group_by_clause", "select_core", 
                   "factored_select_stmt", "simple_select_stmt", "compound_select_stmt", 
                   "table_or_subquery", "result_column", "join_operator", 
                   "join_constraint", "compound_operator", "column_name_list", 
                   "qualified_table_name", "filter_clause", "over_clause", 
                   "frame_spec", "frame_clause", "simple_function_invocation", 
                   "aggregate_function_invocation", "common_table_stmt", 
                   "order_by_stmt", "limit_stmt", "ordering_term", "asc_desc", 
                   "frame_left", "frame_right", "frame_single", "offset", 
                   "default_value", "partition_by", "order_by_expr", "order_by_expr_asc_desc", 
                   "expr_asc_desc", "initial_select", "recursive_select", 
                   "unary_operator", "error_message", "column_alias", "keyword", 
                   "name", "function_name", "schema_name", "table_name", 
                   "table_or_index_name", "new_table_name", "column_name", 
                   "collation_name", "foreign_table", "index_name", "trigger_name", 
                   "view_name", "module_name", "pragma_name", "savepoint_name", 
                   "table_alias", "transaction_name", "window_name", "alias", 
                   "filename", "base_window_name", "simple_func", "aggregate_func", 
                   "table_function_name", "any_name" ]

    EOF = Token.EOF
    SCOL=1
    DOT=2
    OPEN_PAR=3
    CLOSE_PAR=4
    COMMA=5
    ASSIGN=6
    STAR=7
    PLUS=8
    MINUS=9
    TILDE=10
    PIPE2=11
    DIV=12
    MOD=13
    LT2=14
    GT2=15
    AMP=16
    PIPE=17
    LT=18
    LT_EQ=19
    GT=20
    GT_EQ=21
    EQ=22
    NOT_EQ1=23
    NOT_EQ2=24
    ABORT_=25
    ACTION_=26
    ADD_=27
    AFTER_=28
    ALL_=29
    ALTER_=30
    ANALYZE_=31
    AND_=32
    AS_=33
    ASC_=34
    ATTACH_=35
    AUTOINCREMENT_=36
    BEFORE_=37
    BEGIN_=38
    BETWEEN_=39
    BY_=40
    CASCADE_=41
    CASE_=42
    CAST_=43
    CHECK_=44
    COLLATE_=45
    COLUMN_=46
    COMMIT_=47
    CONFLICT_=48
    CONSTRAINT_=49
    CREATE_=50
    CROSS_=51
    CURRENT_DATE_=52
    CURRENT_TIME_=53
    CURRENT_TIMESTAMP_=54
    DATABASE_=55
    DEFAULT_=56
    DEFERRABLE_=57
    DEFERRED_=58
    DELETE_=59
    DESC_=60
    DETACH_=61
    DISTINCT_=62
    DROP_=63
    EACH_=64
    ELSE_=65
    END_=66
    ESCAPE_=67
    EXCEPT_=68
    EXCLUSIVE_=69
    EXISTS_=70
    EXPLAIN_=71
    FAIL_=72
    FOR_=73
    FOREIGN_=74
    FROM_=75
    FULL_=76
    GLOB_=77
    GROUP_=78
    GROUP_BY_=79
    HAVING_=80
    IF_=81
    IGNORE_=82
    IMMEDIATE_=83
    IN_=84
    INDEX_=85
    INDEXED_=86
    INITIALLY_=87
    INNER_=88
    INSERT_=89
    INSTEAD_=90
    INTERSECT_=91
    INTO_=92
    IS_=93
    ISNULL_=94
    JOIN_=95
    KEY_=96
    LEFT_=97
    LIKE_=98
    LIMIT_=99
    MATCH_=100
    NATURAL_=101
    NO_=102
    NOT_=103
    NOTNULL_=104
    NULL_=105
    OF_=106
    OFFSET_=107
    ON_=108
    OR_=109
    ORDER_=110
    ORDER_BY_=111
    OUTER_=112
    PLAN_=113
    PRAGMA_=114
    PRIMARY_=115
    QUERY_=116
    RAISE_=117
    RECURSIVE_=118
    REFERENCES_=119
    REGEXP_=120
    REINDEX_=121
    RELEASE_=122
    RENAME_=123
    REPLACE_=124
    RESTRICT_=125
    RETURNING_=126
    RIGHT_=127
    ROLLBACK_=128
    ROW_=129
    ROWS_=130
    SAVEPOINT_=131
    SELECT_=132
    SET_=133
    TABLE_=134
    TEMP_=135
    TEMPORARY_=136
    THEN_=137
    TO_=138
    TRANSACTION_=139
    TRIGGER_=140
    UNION_=141
    UNIQUE_=142
    UPDATE_=143
    USING_=144
    VACUUM_=145
    VALUES_=146
    VIEW_=147
    VIRTUAL_=148
    WHEN_=149
    WHERE_=150
    WITH_=151
    WITHOUT_=152
    FIRST_VALUE_=153
    OVER_=154
    PARTITION_=155
    RANGE_=156
    PRECEDING_=157
    UNBOUNDED_=158
    CURRENT_=159
    FOLLOWING_=160
    CUME_DIST_=161
    DENSE_RANK_=162
    LAG_=163
    LAST_VALUE_=164
    LEAD_=165
    NTH_VALUE_=166
    NTILE_=167
    PERCENT_RANK_=168
    RANK_=169
    ROW_NUMBER_=170
    GENERATED_=171
    ALWAYS_=172
    STORED_=173
    TRUE_=174
    FALSE_=175
    WINDOW_=176
    NULLS_=177
    FIRST_=178
    LAST_=179
    FILTER_=180
    GROUPS_=181
    EXCLUDE_=182
    TIES_=183
    OTHERS_=184
    DO_=185
    NOTHING_=186
    IDENTIFIER=187
    NUMERIC_LITERAL=188
    BIND_PARAMETER=189
    STRING_LITERAL=190
    BLOB_LITERAL=191
    SINGLE_LINE_COMMENT=192
    MULTILINE_COMMENT=193
    SPACES=194
    UNEXPECTED_CHAR=195

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.11.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ParseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SQLiteParser.EOF, 0)

        def sql_stmt_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Sql_stmt_listContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Sql_stmt_listContext,i)


        def getRuleIndex(self):
            return SQLiteParser.RULE_parse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParse" ):
                listener.enterParse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParse" ):
                listener.exitParse(self)




    def parse(self):

        localctx = SQLiteParser.ParseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_parse)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1 or _la==71 or _la==132 or _la==151:
                self.state = 154
                self.sql_stmt_list()
                self.state = 159
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 160
            self.match(SQLiteParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sql_stmt_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sql_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Sql_stmtContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Sql_stmtContext,i)


        def SCOL(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.SCOL)
            else:
                return self.getToken(SQLiteParser.SCOL, i)

        def getRuleIndex(self):
            return SQLiteParser.RULE_sql_stmt_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSql_stmt_list" ):
                listener.enterSql_stmt_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSql_stmt_list" ):
                listener.exitSql_stmt_list(self)




    def sql_stmt_list(self):

        localctx = SQLiteParser.Sql_stmt_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_sql_stmt_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1:
                self.state = 162
                self.match(SQLiteParser.SCOL)
                self.state = 167
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 168
            self.sql_stmt()
            self.state = 177
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 170 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 169
                        self.match(SQLiteParser.SCOL)
                        self.state = 172 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la==1):
                            break

                    self.state = 174
                    self.sql_stmt() 
                self.state = 179
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

            self.state = 183
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 180
                    self.match(SQLiteParser.SCOL) 
                self.state = 185
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sql_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Select_stmtContext,0)


        def EXPLAIN_(self):
            return self.getToken(SQLiteParser.EXPLAIN_, 0)

        def QUERY_(self):
            return self.getToken(SQLiteParser.QUERY_, 0)

        def PLAN_(self):
            return self.getToken(SQLiteParser.PLAN_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_sql_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSql_stmt" ):
                listener.enterSql_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSql_stmt" ):
                listener.exitSql_stmt(self)




    def sql_stmt(self):

        localctx = SQLiteParser.Sql_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_sql_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 186
                self.match(SQLiteParser.EXPLAIN_)
                self.state = 189
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==116:
                    self.state = 187
                    self.match(SQLiteParser.QUERY_)
                    self.state = 188
                    self.match(SQLiteParser.PLAN_)




            self.state = 193
            self.select_stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.NameContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.NameContext,i)


        def OPEN_PAR(self):
            return self.getToken(SQLiteParser.OPEN_PAR, 0)

        def signed_number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Signed_numberContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Signed_numberContext,i)


        def CLOSE_PAR(self):
            return self.getToken(SQLiteParser.CLOSE_PAR, 0)

        def COMMA(self):
            return self.getToken(SQLiteParser.COMMA, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_type_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_name" ):
                listener.enterType_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_name" ):
                listener.exitType_name(self)




    def type_name(self):

        localctx = SQLiteParser.Type_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_type_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196 
            self._errHandler.sync(self)
            _alt = 1+1
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1+1:
                    self.state = 195
                    self.name()

                else:
                    raise NoViableAltException(self)
                self.state = 198 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

            self.state = 210
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.state = 200
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 201
                self.signed_number()
                self.state = 202
                self.match(SQLiteParser.CLOSE_PAR)

            elif la_ == 2:
                self.state = 204
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 205
                self.signed_number()
                self.state = 206
                self.match(SQLiteParser.COMMA)
                self.state = 207
                self.signed_number()
                self.state = 208
                self.match(SQLiteParser.CLOSE_PAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIC_LITERAL(self):
            return self.getToken(SQLiteParser.NUMERIC_LITERAL, 0)

        def PLUS(self):
            return self.getToken(SQLiteParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(SQLiteParser.MINUS, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_signed_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigned_number" ):
                listener.enterSigned_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigned_number" ):
                listener.exitSigned_number(self)




    def signed_number(self):

        localctx = SQLiteParser.Signed_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_signed_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8 or _la==9:
                self.state = 212
                _la = self._input.LA(1)
                if not(_la==8 or _la==9):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 215
            self.match(SQLiteParser.NUMERIC_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Common_table_expressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(SQLiteParser.Table_nameContext,0)


        def AS_(self):
            return self.getToken(SQLiteParser.AS_, 0)

        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.OPEN_PAR)
            else:
                return self.getToken(SQLiteParser.OPEN_PAR, i)

        def select_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Select_stmtContext,0)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.CLOSE_PAR)
            else:
                return self.getToken(SQLiteParser.CLOSE_PAR, i)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Column_nameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def getRuleIndex(self):
            return SQLiteParser.RULE_common_table_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommon_table_expression" ):
                listener.enterCommon_table_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommon_table_expression" ):
                listener.exitCommon_table_expression(self)




    def common_table_expression(self):

        localctx = SQLiteParser.Common_table_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_common_table_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 217
            self.table_name()
            self.state = 229
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3:
                self.state = 218
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 219
                self.column_name()
                self.state = 224
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==5:
                    self.state = 220
                    self.match(SQLiteParser.COMMA)
                    self.state = 221
                    self.column_name()
                    self.state = 226
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 227
                self.match(SQLiteParser.CLOSE_PAR)


            self.state = 231
            self.match(SQLiteParser.AS_)
            self.state = 232
            self.match(SQLiteParser.OPEN_PAR)
            self.state = 233
            self.select_stmt()
            self.state = 234
            self.match(SQLiteParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal_value(self):
            return self.getTypedRuleContext(SQLiteParser.Literal_valueContext,0)


        def BIND_PARAMETER(self):
            return self.getToken(SQLiteParser.BIND_PARAMETER, 0)

        def column_name(self):
            return self.getTypedRuleContext(SQLiteParser.Column_nameContext,0)


        def table_name(self):
            return self.getTypedRuleContext(SQLiteParser.Table_nameContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.DOT)
            else:
                return self.getToken(SQLiteParser.DOT, i)

        def schema_name(self):
            return self.getTypedRuleContext(SQLiteParser.Schema_nameContext,0)


        def unary_operator(self):
            return self.getTypedRuleContext(SQLiteParser.Unary_operatorContext,0)


        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.ExprContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.ExprContext,i)


        def function_name(self):
            return self.getTypedRuleContext(SQLiteParser.Function_nameContext,0)


        def OPEN_PAR(self):
            return self.getToken(SQLiteParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(SQLiteParser.CLOSE_PAR, 0)

        def STAR(self):
            return self.getToken(SQLiteParser.STAR, 0)

        def filter_clause(self):
            return self.getTypedRuleContext(SQLiteParser.Filter_clauseContext,0)


        def over_clause(self):
            return self.getTypedRuleContext(SQLiteParser.Over_clauseContext,0)


        def DISTINCT_(self):
            return self.getToken(SQLiteParser.DISTINCT_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def CAST_(self):
            return self.getToken(SQLiteParser.CAST_, 0)

        def AS_(self):
            return self.getToken(SQLiteParser.AS_, 0)

        def type_name(self):
            return self.getTypedRuleContext(SQLiteParser.Type_nameContext,0)


        def select_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Select_stmtContext,0)


        def EXISTS_(self):
            return self.getToken(SQLiteParser.EXISTS_, 0)

        def NOT_(self):
            return self.getToken(SQLiteParser.NOT_, 0)

        def CASE_(self):
            return self.getToken(SQLiteParser.CASE_, 0)

        def END_(self):
            return self.getToken(SQLiteParser.END_, 0)

        def WHEN_(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.WHEN_)
            else:
                return self.getToken(SQLiteParser.WHEN_, i)

        def THEN_(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.THEN_)
            else:
                return self.getToken(SQLiteParser.THEN_, i)

        def ELSE_(self):
            return self.getToken(SQLiteParser.ELSE_, 0)

        def raise_function(self):
            return self.getTypedRuleContext(SQLiteParser.Raise_functionContext,0)


        def PIPE2(self):
            return self.getToken(SQLiteParser.PIPE2, 0)

        def DIV(self):
            return self.getToken(SQLiteParser.DIV, 0)

        def MOD(self):
            return self.getToken(SQLiteParser.MOD, 0)

        def PLUS(self):
            return self.getToken(SQLiteParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(SQLiteParser.MINUS, 0)

        def LT2(self):
            return self.getToken(SQLiteParser.LT2, 0)

        def GT2(self):
            return self.getToken(SQLiteParser.GT2, 0)

        def AMP(self):
            return self.getToken(SQLiteParser.AMP, 0)

        def PIPE(self):
            return self.getToken(SQLiteParser.PIPE, 0)

        def LT(self):
            return self.getToken(SQLiteParser.LT, 0)

        def LT_EQ(self):
            return self.getToken(SQLiteParser.LT_EQ, 0)

        def GT(self):
            return self.getToken(SQLiteParser.GT, 0)

        def GT_EQ(self):
            return self.getToken(SQLiteParser.GT_EQ, 0)

        def ASSIGN(self):
            return self.getToken(SQLiteParser.ASSIGN, 0)

        def EQ(self):
            return self.getToken(SQLiteParser.EQ, 0)

        def NOT_EQ1(self):
            return self.getToken(SQLiteParser.NOT_EQ1, 0)

        def NOT_EQ2(self):
            return self.getToken(SQLiteParser.NOT_EQ2, 0)

        def IS_(self):
            return self.getToken(SQLiteParser.IS_, 0)

        def IN_(self):
            return self.getToken(SQLiteParser.IN_, 0)

        def LIKE_(self):
            return self.getToken(SQLiteParser.LIKE_, 0)

        def GLOB_(self):
            return self.getToken(SQLiteParser.GLOB_, 0)

        def MATCH_(self):
            return self.getToken(SQLiteParser.MATCH_, 0)

        def REGEXP_(self):
            return self.getToken(SQLiteParser.REGEXP_, 0)

        def AND_(self):
            return self.getToken(SQLiteParser.AND_, 0)

        def OR_(self):
            return self.getToken(SQLiteParser.OR_, 0)

        def BETWEEN_(self):
            return self.getToken(SQLiteParser.BETWEEN_, 0)

        def COLLATE_(self):
            return self.getToken(SQLiteParser.COLLATE_, 0)

        def collation_name(self):
            return self.getTypedRuleContext(SQLiteParser.Collation_nameContext,0)


        def ESCAPE_(self):
            return self.getToken(SQLiteParser.ESCAPE_, 0)

        def ISNULL_(self):
            return self.getToken(SQLiteParser.ISNULL_, 0)

        def NOTNULL_(self):
            return self.getToken(SQLiteParser.NOTNULL_, 0)

        def NULL_(self):
            return self.getToken(SQLiteParser.NULL_, 0)

        def table_function_name(self):
            return self.getTypedRuleContext(SQLiteParser.Table_function_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SQLiteParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 12
        self.enterRecursionRule(localctx, 12, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.state = 237
                self.literal_value()
                pass

            elif la_ == 2:
                self.state = 238
                self.match(SQLiteParser.BIND_PARAMETER)
                pass

            elif la_ == 3:
                self.state = 247
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
                if la_ == 1:
                    self.state = 242
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
                    if la_ == 1:
                        self.state = 239
                        self.schema_name()
                        self.state = 240
                        self.match(SQLiteParser.DOT)


                    self.state = 244
                    self.table_name()
                    self.state = 245
                    self.match(SQLiteParser.DOT)


                self.state = 249
                self.column_name()
                pass

            elif la_ == 4:
                self.state = 250
                self.unary_operator()
                self.state = 251
                self.expr(21)
                pass

            elif la_ == 5:
                self.state = 253
                self.function_name()
                self.state = 254
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 267
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [3, 8, 9, 10, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 187, 188, 189, 190, 191]:
                    self.state = 256
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
                    if la_ == 1:
                        self.state = 255
                        self.match(SQLiteParser.DISTINCT_)


                    self.state = 258
                    self.expr(0)
                    self.state = 263
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==5:
                        self.state = 259
                        self.match(SQLiteParser.COMMA)
                        self.state = 260
                        self.expr(0)
                        self.state = 265
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass
                elif token in [7]:
                    self.state = 266
                    self.match(SQLiteParser.STAR)
                    pass
                elif token in [4]:
                    pass
                else:
                    pass
                self.state = 269
                self.match(SQLiteParser.CLOSE_PAR)
                self.state = 271
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
                if la_ == 1:
                    self.state = 270
                    self.filter_clause()


                self.state = 274
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
                if la_ == 1:
                    self.state = 273
                    self.over_clause()


                pass

            elif la_ == 6:
                self.state = 276
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 277
                self.expr(0)
                self.state = 282
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==5:
                    self.state = 278
                    self.match(SQLiteParser.COMMA)
                    self.state = 279
                    self.expr(0)
                    self.state = 284
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 285
                self.match(SQLiteParser.CLOSE_PAR)
                pass

            elif la_ == 7:
                self.state = 287
                self.match(SQLiteParser.CAST_)
                self.state = 288
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 289
                self.expr(0)
                self.state = 290
                self.match(SQLiteParser.AS_)
                self.state = 291
                self.type_name()
                self.state = 292
                self.match(SQLiteParser.CLOSE_PAR)
                pass

            elif la_ == 8:
                self.state = 298
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==70 or _la==103:
                    self.state = 295
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==103:
                        self.state = 294
                        self.match(SQLiteParser.NOT_)


                    self.state = 297
                    self.match(SQLiteParser.EXISTS_)


                self.state = 300
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 301
                self.select_stmt()
                self.state = 302
                self.match(SQLiteParser.CLOSE_PAR)
                pass

            elif la_ == 9:
                self.state = 304
                self.match(SQLiteParser.CASE_)
                self.state = 306
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
                if la_ == 1:
                    self.state = 305
                    self.expr(0)


                self.state = 313 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 308
                    self.match(SQLiteParser.WHEN_)
                    self.state = 309
                    self.expr(0)
                    self.state = 310
                    self.match(SQLiteParser.THEN_)
                    self.state = 311
                    self.expr(0)
                    self.state = 315 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==149):
                        break

                self.state = 319
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==65:
                    self.state = 317
                    self.match(SQLiteParser.ELSE_)
                    self.state = 318
                    self.expr(0)


                self.state = 321
                self.match(SQLiteParser.END_)
                pass

            elif la_ == 10:
                self.state = 323
                self.raise_function()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 445
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,41,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 443
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
                    if la_ == 1:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 326
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 327
                        self.match(SQLiteParser.PIPE2)
                        self.state = 328
                        self.expr(21)
                        pass

                    elif la_ == 2:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 329
                        if not self.precpred(self._ctx, 19):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
                        self.state = 330
                        _la = self._input.LA(1)
                        if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 12416) != 0):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 331
                        self.expr(20)
                        pass

                    elif la_ == 3:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 332
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 333
                        _la = self._input.LA(1)
                        if not(_la==8 or _la==9):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 334
                        self.expr(19)
                        pass

                    elif la_ == 4:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 335
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 336
                        _la = self._input.LA(1)
                        if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 245760) != 0):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 337
                        self.expr(18)
                        pass

                    elif la_ == 5:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 338
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 339
                        _la = self._input.LA(1)
                        if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 3932160) != 0):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 340
                        self.expr(17)
                        pass

                    elif la_ == 6:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 341
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 354
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
                        if la_ == 1:
                            self.state = 342
                            self.match(SQLiteParser.ASSIGN)
                            pass

                        elif la_ == 2:
                            self.state = 343
                            self.match(SQLiteParser.EQ)
                            pass

                        elif la_ == 3:
                            self.state = 344
                            self.match(SQLiteParser.NOT_EQ1)
                            pass

                        elif la_ == 4:
                            self.state = 345
                            self.match(SQLiteParser.NOT_EQ2)
                            pass

                        elif la_ == 5:
                            self.state = 346
                            self.match(SQLiteParser.IS_)
                            pass

                        elif la_ == 6:
                            self.state = 347
                            self.match(SQLiteParser.IS_)
                            self.state = 348
                            self.match(SQLiteParser.NOT_)
                            pass

                        elif la_ == 7:
                            self.state = 349
                            self.match(SQLiteParser.IN_)
                            pass

                        elif la_ == 8:
                            self.state = 350
                            self.match(SQLiteParser.LIKE_)
                            pass

                        elif la_ == 9:
                            self.state = 351
                            self.match(SQLiteParser.GLOB_)
                            pass

                        elif la_ == 10:
                            self.state = 352
                            self.match(SQLiteParser.MATCH_)
                            pass

                        elif la_ == 11:
                            self.state = 353
                            self.match(SQLiteParser.REGEXP_)
                            pass


                        self.state = 356
                        self.expr(16)
                        pass

                    elif la_ == 7:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 357
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 358
                        self.match(SQLiteParser.AND_)
                        self.state = 359
                        self.expr(15)
                        pass

                    elif la_ == 8:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 360
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 361
                        self.match(SQLiteParser.OR_)
                        self.state = 362
                        self.expr(14)
                        pass

                    elif la_ == 9:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 363
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 364
                        self.match(SQLiteParser.IS_)
                        self.state = 366
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
                        if la_ == 1:
                            self.state = 365
                            self.match(SQLiteParser.NOT_)


                        self.state = 368
                        self.expr(7)
                        pass

                    elif la_ == 10:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 369
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 371
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==103:
                            self.state = 370
                            self.match(SQLiteParser.NOT_)


                        self.state = 373
                        self.match(SQLiteParser.BETWEEN_)
                        self.state = 374
                        self.expr(0)
                        self.state = 375
                        self.match(SQLiteParser.AND_)
                        self.state = 376
                        self.expr(6)
                        pass

                    elif la_ == 11:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 378
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 379
                        self.match(SQLiteParser.COLLATE_)
                        self.state = 380
                        self.collation_name()
                        pass

                    elif la_ == 12:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 381
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 383
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==103:
                            self.state = 382
                            self.match(SQLiteParser.NOT_)


                        self.state = 385
                        _la = self._input.LA(1)
                        if not((((_la - 77)) & ~0x3f) == 0 and ((1 << (_la - 77)) & 8796103507969) != 0):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 386
                        self.expr(0)
                        self.state = 389
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
                        if la_ == 1:
                            self.state = 387
                            self.match(SQLiteParser.ESCAPE_)
                            self.state = 388
                            self.expr(0)


                        pass

                    elif la_ == 13:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 391
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 396
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [94]:
                            self.state = 392
                            self.match(SQLiteParser.ISNULL_)
                            pass
                        elif token in [104]:
                            self.state = 393
                            self.match(SQLiteParser.NOTNULL_)
                            pass
                        elif token in [103]:
                            self.state = 394
                            self.match(SQLiteParser.NOT_)
                            self.state = 395
                            self.match(SQLiteParser.NULL_)
                            pass
                        else:
                            raise NoViableAltException(self)

                        pass

                    elif la_ == 14:
                        localctx = SQLiteParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 398
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 400
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==103:
                            self.state = 399
                            self.match(SQLiteParser.NOT_)


                        self.state = 402
                        self.match(SQLiteParser.IN_)
                        self.state = 441
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
                        if la_ == 1:
                            self.state = 403
                            self.match(SQLiteParser.OPEN_PAR)
                            self.state = 413
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
                            if la_ == 1:
                                self.state = 404
                                self.select_stmt()

                            elif la_ == 2:
                                self.state = 405
                                self.expr(0)
                                self.state = 410
                                self._errHandler.sync(self)
                                _la = self._input.LA(1)
                                while _la==5:
                                    self.state = 406
                                    self.match(SQLiteParser.COMMA)
                                    self.state = 407
                                    self.expr(0)
                                    self.state = 412
                                    self._errHandler.sync(self)
                                    _la = self._input.LA(1)



                            self.state = 415
                            self.match(SQLiteParser.CLOSE_PAR)
                            pass

                        elif la_ == 2:
                            self.state = 419
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
                            if la_ == 1:
                                self.state = 416
                                self.schema_name()
                                self.state = 417
                                self.match(SQLiteParser.DOT)


                            self.state = 421
                            self.table_name()
                            pass

                        elif la_ == 3:
                            self.state = 425
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
                            if la_ == 1:
                                self.state = 422
                                self.schema_name()
                                self.state = 423
                                self.match(SQLiteParser.DOT)


                            self.state = 427
                            self.table_function_name()
                            self.state = 428
                            self.match(SQLiteParser.OPEN_PAR)
                            self.state = 437
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if ((_la) & ~0x3f) == 0 and ((1 << _la) & -33552632) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & -4611826755915776001) != 0 or (((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -540431955284459521) != 0:
                                self.state = 429
                                self.expr(0)
                                self.state = 434
                                self._errHandler.sync(self)
                                _la = self._input.LA(1)
                                while _la==5:
                                    self.state = 430
                                    self.match(SQLiteParser.COMMA)
                                    self.state = 431
                                    self.expr(0)
                                    self.state = 436
                                    self._errHandler.sync(self)
                                    _la = self._input.LA(1)



                            self.state = 439
                            self.match(SQLiteParser.CLOSE_PAR)
                            pass


                        pass

             
                self.state = 447
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,41,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Raise_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RAISE_(self):
            return self.getToken(SQLiteParser.RAISE_, 0)

        def OPEN_PAR(self):
            return self.getToken(SQLiteParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(SQLiteParser.CLOSE_PAR, 0)

        def IGNORE_(self):
            return self.getToken(SQLiteParser.IGNORE_, 0)

        def COMMA(self):
            return self.getToken(SQLiteParser.COMMA, 0)

        def error_message(self):
            return self.getTypedRuleContext(SQLiteParser.Error_messageContext,0)


        def ROLLBACK_(self):
            return self.getToken(SQLiteParser.ROLLBACK_, 0)

        def ABORT_(self):
            return self.getToken(SQLiteParser.ABORT_, 0)

        def FAIL_(self):
            return self.getToken(SQLiteParser.FAIL_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_raise_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRaise_function" ):
                listener.enterRaise_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRaise_function" ):
                listener.exitRaise_function(self)




    def raise_function(self):

        localctx = SQLiteParser.Raise_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_raise_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 448
            self.match(SQLiteParser.RAISE_)
            self.state = 449
            self.match(SQLiteParser.OPEN_PAR)
            self.state = 454
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [82]:
                self.state = 450
                self.match(SQLiteParser.IGNORE_)
                pass
            elif token in [25, 72, 128]:
                self.state = 451
                _la = self._input.LA(1)
                if not(_la==25 or _la==72 or _la==128):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 452
                self.match(SQLiteParser.COMMA)
                self.state = 453
                self.error_message()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 456
            self.match(SQLiteParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Literal_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIC_LITERAL(self):
            return self.getToken(SQLiteParser.NUMERIC_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(SQLiteParser.STRING_LITERAL, 0)

        def BLOB_LITERAL(self):
            return self.getToken(SQLiteParser.BLOB_LITERAL, 0)

        def NULL_(self):
            return self.getToken(SQLiteParser.NULL_, 0)

        def TRUE_(self):
            return self.getToken(SQLiteParser.TRUE_, 0)

        def FALSE_(self):
            return self.getToken(SQLiteParser.FALSE_, 0)

        def CURRENT_TIME_(self):
            return self.getToken(SQLiteParser.CURRENT_TIME_, 0)

        def CURRENT_DATE_(self):
            return self.getToken(SQLiteParser.CURRENT_DATE_, 0)

        def CURRENT_TIMESTAMP_(self):
            return self.getToken(SQLiteParser.CURRENT_TIMESTAMP_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_literal_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral_value" ):
                listener.enterLiteral_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral_value" ):
                listener.exitLiteral_value(self)




    def literal_value(self):

        localctx = SQLiteParser.Literal_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_literal_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 458
            _la = self._input.LA(1)
            if not((((_la - 52)) & ~0x3f) == 0 and ((1 << (_la - 52)) & 9007199254740999) != 0 or (((_la - 174)) & ~0x3f) == 0 and ((1 << (_la - 174)) & 212995) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_core(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Select_coreContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Select_coreContext,i)


        def common_table_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Common_table_stmtContext,0)


        def compound_operator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Compound_operatorContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Compound_operatorContext,i)


        def order_by_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Order_by_stmtContext,0)


        def limit_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Limit_stmtContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_select_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_stmt" ):
                listener.enterSelect_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_stmt" ):
                listener.exitSelect_stmt(self)




    def select_stmt(self):

        localctx = SQLiteParser.Select_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_select_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 461
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==151:
                self.state = 460
                self.common_table_stmt()


            self.state = 463
            self.select_core()
            self.state = 469
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==68 or _la==91 or _la==141:
                self.state = 464
                self.compound_operator()
                self.state = 465
                self.select_core()
                self.state = 471
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 473
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==111:
                self.state = 472
                self.order_by_stmt()


            self.state = 476
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==99:
                self.state = 475
                self.limit_stmt()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Join_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_or_subquery(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Table_or_subqueryContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Table_or_subqueryContext,i)


        def join_operator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Join_operatorContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Join_operatorContext,i)


        def join_constraint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Join_constraintContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Join_constraintContext,i)


        def getRuleIndex(self):
            return SQLiteParser.RULE_join_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoin_clause" ):
                listener.enterJoin_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoin_clause" ):
                listener.exitJoin_clause(self)




    def join_clause(self):

        localctx = SQLiteParser.Join_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_join_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 478
            self.table_or_subquery()
            self.state = 486
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5 or _la==51 or (((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 8833) != 0:
                self.state = 479
                self.join_operator()
                self.state = 480
                self.table_or_subquery()
                self.state = 482
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==108 or _la==144:
                    self.state = 481
                    self.join_constraint()


                self.state = 488
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Result_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def result_column(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Result_columnContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Result_columnContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def getRuleIndex(self):
            return SQLiteParser.RULE_result_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResult_clause" ):
                listener.enterResult_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResult_clause" ):
                listener.exitResult_clause(self)




    def result_clause(self):

        localctx = SQLiteParser.Result_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_result_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 489
            self.result_column()
            self.state = 494
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 490
                self.match(SQLiteParser.COMMA)
                self.state = 491
                self.result_column()
                self.state = 496
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM_(self):
            return self.getToken(SQLiteParser.FROM_, 0)

        def table_or_subquery(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Table_or_subqueryContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Table_or_subqueryContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def join_clause(self):
            return self.getTypedRuleContext(SQLiteParser.Join_clauseContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_from_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_clause" ):
                listener.enterFrom_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_clause" ):
                listener.exitFrom_clause(self)




    def from_clause(self):

        localctx = SQLiteParser.From_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_from_clause)
        self._la = 0 # Token type
        try:
            self.state = 508
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 497
                self.match(SQLiteParser.FROM_)
                self.state = 498
                self.table_or_subquery()
                self.state = 503
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==5:
                    self.state = 499
                    self.match(SQLiteParser.COMMA)
                    self.state = 500
                    self.table_or_subquery()
                    self.state = 505
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 506
                self.match(SQLiteParser.FROM_)
                self.state = 507
                self.join_clause()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Where_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE_(self):
            return self.getToken(SQLiteParser.WHERE_, 0)

        def expr(self):
            return self.getTypedRuleContext(SQLiteParser.ExprContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_where_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhere_clause" ):
                listener.enterWhere_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhere_clause" ):
                listener.exitWhere_clause(self)




    def where_clause(self):

        localctx = SQLiteParser.Where_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_where_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 510
            self.match(SQLiteParser.WHERE_)
            self.state = 511
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Group_by_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GROUP_BY_(self):
            return self.getToken(SQLiteParser.GROUP_BY_, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.ExprContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def HAVING_(self):
            return self.getToken(SQLiteParser.HAVING_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_group_by_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroup_by_clause" ):
                listener.enterGroup_by_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroup_by_clause" ):
                listener.exitGroup_by_clause(self)




    def group_by_clause(self):

        localctx = SQLiteParser.Group_by_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_group_by_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 513
            self.match(SQLiteParser.GROUP_BY_)
            self.state = 514
            self.expr(0)
            self.state = 519
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 515
                self.match(SQLiteParser.COMMA)
                self.state = 516
                self.expr(0)
                self.state = 521
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 524
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==80:
                self.state = 522
                self.match(SQLiteParser.HAVING_)
                self.state = 523
                self.expr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_coreContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT_(self):
            return self.getToken(SQLiteParser.SELECT_, 0)

        def result_clause(self):
            return self.getTypedRuleContext(SQLiteParser.Result_clauseContext,0)


        def from_clause(self):
            return self.getTypedRuleContext(SQLiteParser.From_clauseContext,0)


        def where_clause(self):
            return self.getTypedRuleContext(SQLiteParser.Where_clauseContext,0)


        def group_by_clause(self):
            return self.getTypedRuleContext(SQLiteParser.Group_by_clauseContext,0)


        def DISTINCT_(self):
            return self.getToken(SQLiteParser.DISTINCT_, 0)

        def ALL_(self):
            return self.getToken(SQLiteParser.ALL_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_select_core

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_core" ):
                listener.enterSelect_core(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_core" ):
                listener.exitSelect_core(self)




    def select_core(self):

        localctx = SQLiteParser.Select_coreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_select_core)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 526
            self.match(SQLiteParser.SELECT_)
            self.state = 528
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.state = 527
                _la = self._input.LA(1)
                if not(_la==29 or _la==62):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 530
            self.result_clause()
            self.state = 532
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==75:
                self.state = 531
                self.from_clause()


            self.state = 535
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==150:
                self.state = 534
                self.where_clause()


            self.state = 538
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==79:
                self.state = 537
                self.group_by_clause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Factored_select_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Select_stmtContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_factored_select_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactored_select_stmt" ):
                listener.enterFactored_select_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactored_select_stmt" ):
                listener.exitFactored_select_stmt(self)




    def factored_select_stmt(self):

        localctx = SQLiteParser.Factored_select_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_factored_select_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 540
            self.select_stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simple_select_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_core(self):
            return self.getTypedRuleContext(SQLiteParser.Select_coreContext,0)


        def common_table_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Common_table_stmtContext,0)


        def order_by_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Order_by_stmtContext,0)


        def limit_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Limit_stmtContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_simple_select_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimple_select_stmt" ):
                listener.enterSimple_select_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimple_select_stmt" ):
                listener.exitSimple_select_stmt(self)




    def simple_select_stmt(self):

        localctx = SQLiteParser.Simple_select_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_simple_select_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 543
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==151:
                self.state = 542
                self.common_table_stmt()


            self.state = 545
            self.select_core()
            self.state = 547
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==111:
                self.state = 546
                self.order_by_stmt()


            self.state = 550
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==99:
                self.state = 549
                self.limit_stmt()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Compound_select_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_core(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Select_coreContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Select_coreContext,i)


        def common_table_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Common_table_stmtContext,0)


        def order_by_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Order_by_stmtContext,0)


        def limit_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Limit_stmtContext,0)


        def UNION_(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.UNION_)
            else:
                return self.getToken(SQLiteParser.UNION_, i)

        def INTERSECT_(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.INTERSECT_)
            else:
                return self.getToken(SQLiteParser.INTERSECT_, i)

        def EXCEPT_(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.EXCEPT_)
            else:
                return self.getToken(SQLiteParser.EXCEPT_, i)

        def ALL_(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.ALL_)
            else:
                return self.getToken(SQLiteParser.ALL_, i)

        def getRuleIndex(self):
            return SQLiteParser.RULE_compound_select_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompound_select_stmt" ):
                listener.enterCompound_select_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompound_select_stmt" ):
                listener.exitCompound_select_stmt(self)




    def compound_select_stmt(self):

        localctx = SQLiteParser.Compound_select_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_compound_select_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 553
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==151:
                self.state = 552
                self.common_table_stmt()


            self.state = 555
            self.select_core()
            self.state = 565 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 562
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [141]:
                    self.state = 556
                    self.match(SQLiteParser.UNION_)
                    self.state = 558
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==29:
                        self.state = 557
                        self.match(SQLiteParser.ALL_)


                    pass
                elif token in [91]:
                    self.state = 560
                    self.match(SQLiteParser.INTERSECT_)
                    pass
                elif token in [68]:
                    self.state = 561
                    self.match(SQLiteParser.EXCEPT_)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 564
                self.select_core()
                self.state = 567 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==68 or _la==91 or _la==141):
                    break

            self.state = 570
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==111:
                self.state = 569
                self.order_by_stmt()


            self.state = 573
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==99:
                self.state = 572
                self.limit_stmt()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_or_subqueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(SQLiteParser.Table_nameContext,0)


        def schema_name(self):
            return self.getTypedRuleContext(SQLiteParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(SQLiteParser.DOT, 0)

        def table_alias(self):
            return self.getTypedRuleContext(SQLiteParser.Table_aliasContext,0)


        def INDEXED_(self):
            return self.getToken(SQLiteParser.INDEXED_, 0)

        def BY_(self):
            return self.getToken(SQLiteParser.BY_, 0)

        def index_name(self):
            return self.getTypedRuleContext(SQLiteParser.Index_nameContext,0)


        def NOT_(self):
            return self.getToken(SQLiteParser.NOT_, 0)

        def AS_(self):
            return self.getToken(SQLiteParser.AS_, 0)

        def table_function_name(self):
            return self.getTypedRuleContext(SQLiteParser.Table_function_nameContext,0)


        def OPEN_PAR(self):
            return self.getToken(SQLiteParser.OPEN_PAR, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.ExprContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.ExprContext,i)


        def CLOSE_PAR(self):
            return self.getToken(SQLiteParser.CLOSE_PAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def table_or_subquery(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Table_or_subqueryContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Table_or_subqueryContext,i)


        def join_clause(self):
            return self.getTypedRuleContext(SQLiteParser.Join_clauseContext,0)


        def select_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Select_stmtContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_table_or_subquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_or_subquery" ):
                listener.enterTable_or_subquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_or_subquery" ):
                listener.exitTable_or_subquery(self)




    def table_or_subquery(self):

        localctx = SQLiteParser.Table_or_subqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_table_or_subquery)
        self._la = 0 # Token type
        try:
            self.state = 639
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 578
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
                if la_ == 1:
                    self.state = 575
                    self.schema_name()
                    self.state = 576
                    self.match(SQLiteParser.DOT)


                self.state = 580
                self.table_name()
                self.state = 585
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
                if la_ == 1:
                    self.state = 582
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
                    if la_ == 1:
                        self.state = 581
                        self.match(SQLiteParser.AS_)


                    self.state = 584
                    self.table_alias()


                self.state = 592
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [86]:
                    self.state = 587
                    self.match(SQLiteParser.INDEXED_)
                    self.state = 588
                    self.match(SQLiteParser.BY_)
                    self.state = 589
                    self.index_name()
                    pass
                elif token in [103]:
                    self.state = 590
                    self.match(SQLiteParser.NOT_)
                    self.state = 591
                    self.match(SQLiteParser.INDEXED_)
                    pass
                elif token in [-1, 1, 4, 5, 51, 68, 71, 79, 88, 91, 95, 97, 99, 101, 108, 111, 132, 141, 144, 150, 151]:
                    pass
                else:
                    pass
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 597
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
                if la_ == 1:
                    self.state = 594
                    self.schema_name()
                    self.state = 595
                    self.match(SQLiteParser.DOT)


                self.state = 599
                self.table_function_name()
                self.state = 600
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 601
                self.expr(0)
                self.state = 606
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==5:
                    self.state = 602
                    self.match(SQLiteParser.COMMA)
                    self.state = 603
                    self.expr(0)
                    self.state = 608
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 609
                self.match(SQLiteParser.CLOSE_PAR)
                self.state = 614
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
                if la_ == 1:
                    self.state = 611
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
                    if la_ == 1:
                        self.state = 610
                        self.match(SQLiteParser.AS_)


                    self.state = 613
                    self.table_alias()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 616
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 626
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
                if la_ == 1:
                    self.state = 617
                    self.table_or_subquery()
                    self.state = 622
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==5:
                        self.state = 618
                        self.match(SQLiteParser.COMMA)
                        self.state = 619
                        self.table_or_subquery()
                        self.state = 624
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass

                elif la_ == 2:
                    self.state = 625
                    self.join_clause()
                    pass


                self.state = 628
                self.match(SQLiteParser.CLOSE_PAR)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 630
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 631
                self.select_stmt()
                self.state = 632
                self.match(SQLiteParser.CLOSE_PAR)
                self.state = 637
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
                if la_ == 1:
                    self.state = 634
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
                    if la_ == 1:
                        self.state = 633
                        self.match(SQLiteParser.AS_)


                    self.state = 636
                    self.table_alias()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Result_columnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STAR(self):
            return self.getToken(SQLiteParser.STAR, 0)

        def table_name(self):
            return self.getTypedRuleContext(SQLiteParser.Table_nameContext,0)


        def DOT(self):
            return self.getToken(SQLiteParser.DOT, 0)

        def expr(self):
            return self.getTypedRuleContext(SQLiteParser.ExprContext,0)


        def column_alias(self):
            return self.getTypedRuleContext(SQLiteParser.Column_aliasContext,0)


        def AS_(self):
            return self.getToken(SQLiteParser.AS_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_result_column

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResult_column" ):
                listener.enterResult_column(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResult_column" ):
                listener.exitResult_column(self)




    def result_column(self):

        localctx = SQLiteParser.Result_columnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_result_column)
        self._la = 0 # Token type
        try:
            self.state = 653
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 641
                self.match(SQLiteParser.STAR)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 642
                self.table_name()
                self.state = 643
                self.match(SQLiteParser.DOT)
                self.state = 644
                self.match(SQLiteParser.STAR)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 646
                self.expr(0)
                self.state = 651
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==33 or _la==187 or _la==190:
                    self.state = 648
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==33:
                        self.state = 647
                        self.match(SQLiteParser.AS_)


                    self.state = 650
                    self.column_alias()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Join_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(SQLiteParser.COMMA, 0)

        def JOIN_(self):
            return self.getToken(SQLiteParser.JOIN_, 0)

        def NATURAL_(self):
            return self.getToken(SQLiteParser.NATURAL_, 0)

        def LEFT_(self):
            return self.getToken(SQLiteParser.LEFT_, 0)

        def INNER_(self):
            return self.getToken(SQLiteParser.INNER_, 0)

        def CROSS_(self):
            return self.getToken(SQLiteParser.CROSS_, 0)

        def OUTER_(self):
            return self.getToken(SQLiteParser.OUTER_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_join_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoin_operator" ):
                listener.enterJoin_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoin_operator" ):
                listener.exitJoin_operator(self)




    def join_operator(self):

        localctx = SQLiteParser.Join_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_join_operator)
        self._la = 0 # Token type
        try:
            self.state = 668
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 655
                self.match(SQLiteParser.COMMA)
                pass
            elif token in [51, 88, 95, 97, 101]:
                self.enterOuterAlt(localctx, 2)
                self.state = 657
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==101:
                    self.state = 656
                    self.match(SQLiteParser.NATURAL_)


                self.state = 665
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [97]:
                    self.state = 659
                    self.match(SQLiteParser.LEFT_)
                    self.state = 661
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==112:
                        self.state = 660
                        self.match(SQLiteParser.OUTER_)


                    pass
                elif token in [88]:
                    self.state = 663
                    self.match(SQLiteParser.INNER_)
                    pass
                elif token in [51]:
                    self.state = 664
                    self.match(SQLiteParser.CROSS_)
                    pass
                elif token in [95]:
                    pass
                else:
                    pass
                self.state = 667
                self.match(SQLiteParser.JOIN_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Join_constraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON_(self):
            return self.getToken(SQLiteParser.ON_, 0)

        def expr(self):
            return self.getTypedRuleContext(SQLiteParser.ExprContext,0)


        def USING_(self):
            return self.getToken(SQLiteParser.USING_, 0)

        def OPEN_PAR(self):
            return self.getToken(SQLiteParser.OPEN_PAR, 0)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Column_nameContext,i)


        def CLOSE_PAR(self):
            return self.getToken(SQLiteParser.CLOSE_PAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def getRuleIndex(self):
            return SQLiteParser.RULE_join_constraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoin_constraint" ):
                listener.enterJoin_constraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoin_constraint" ):
                listener.exitJoin_constraint(self)




    def join_constraint(self):

        localctx = SQLiteParser.Join_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_join_constraint)
        self._la = 0 # Token type
        try:
            self.state = 684
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [108]:
                self.enterOuterAlt(localctx, 1)
                self.state = 670
                self.match(SQLiteParser.ON_)
                self.state = 671
                self.expr(0)
                pass
            elif token in [144]:
                self.enterOuterAlt(localctx, 2)
                self.state = 672
                self.match(SQLiteParser.USING_)
                self.state = 673
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 674
                self.column_name()
                self.state = 679
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==5:
                    self.state = 675
                    self.match(SQLiteParser.COMMA)
                    self.state = 676
                    self.column_name()
                    self.state = 681
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 682
                self.match(SQLiteParser.CLOSE_PAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Compound_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNION_(self):
            return self.getToken(SQLiteParser.UNION_, 0)

        def ALL_(self):
            return self.getToken(SQLiteParser.ALL_, 0)

        def INTERSECT_(self):
            return self.getToken(SQLiteParser.INTERSECT_, 0)

        def EXCEPT_(self):
            return self.getToken(SQLiteParser.EXCEPT_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_compound_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompound_operator" ):
                listener.enterCompound_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompound_operator" ):
                listener.exitCompound_operator(self)




    def compound_operator(self):

        localctx = SQLiteParser.Compound_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_compound_operator)
        self._la = 0 # Token type
        try:
            self.state = 692
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [141]:
                self.enterOuterAlt(localctx, 1)
                self.state = 686
                self.match(SQLiteParser.UNION_)
                self.state = 688
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 687
                    self.match(SQLiteParser.ALL_)


                pass
            elif token in [91]:
                self.enterOuterAlt(localctx, 2)
                self.state = 690
                self.match(SQLiteParser.INTERSECT_)
                pass
            elif token in [68]:
                self.enterOuterAlt(localctx, 3)
                self.state = 691
                self.match(SQLiteParser.EXCEPT_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_name_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR(self):
            return self.getToken(SQLiteParser.OPEN_PAR, 0)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Column_nameContext,i)


        def CLOSE_PAR(self):
            return self.getToken(SQLiteParser.CLOSE_PAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def getRuleIndex(self):
            return SQLiteParser.RULE_column_name_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_name_list" ):
                listener.enterColumn_name_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_name_list" ):
                listener.exitColumn_name_list(self)




    def column_name_list(self):

        localctx = SQLiteParser.Column_name_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_column_name_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 694
            self.match(SQLiteParser.OPEN_PAR)
            self.state = 695
            self.column_name()
            self.state = 700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 696
                self.match(SQLiteParser.COMMA)
                self.state = 697
                self.column_name()
                self.state = 702
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 703
            self.match(SQLiteParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Qualified_table_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(SQLiteParser.Table_nameContext,0)


        def schema_name(self):
            return self.getTypedRuleContext(SQLiteParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(SQLiteParser.DOT, 0)

        def AS_(self):
            return self.getToken(SQLiteParser.AS_, 0)

        def alias(self):
            return self.getTypedRuleContext(SQLiteParser.AliasContext,0)


        def INDEXED_(self):
            return self.getToken(SQLiteParser.INDEXED_, 0)

        def BY_(self):
            return self.getToken(SQLiteParser.BY_, 0)

        def index_name(self):
            return self.getTypedRuleContext(SQLiteParser.Index_nameContext,0)


        def NOT_(self):
            return self.getToken(SQLiteParser.NOT_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_qualified_table_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualified_table_name" ):
                listener.enterQualified_table_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualified_table_name" ):
                listener.exitQualified_table_name(self)




    def qualified_table_name(self):

        localctx = SQLiteParser.Qualified_table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_qualified_table_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 708
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
            if la_ == 1:
                self.state = 705
                self.schema_name()
                self.state = 706
                self.match(SQLiteParser.DOT)


            self.state = 710
            self.table_name()
            self.state = 713
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 711
                self.match(SQLiteParser.AS_)
                self.state = 712
                self.alias()


            self.state = 720
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [86]:
                self.state = 715
                self.match(SQLiteParser.INDEXED_)
                self.state = 716
                self.match(SQLiteParser.BY_)
                self.state = 717
                self.index_name()
                pass
            elif token in [103]:
                self.state = 718
                self.match(SQLiteParser.NOT_)
                self.state = 719
                self.match(SQLiteParser.INDEXED_)
                pass
            elif token in [-1]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Filter_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILTER_(self):
            return self.getToken(SQLiteParser.FILTER_, 0)

        def OPEN_PAR(self):
            return self.getToken(SQLiteParser.OPEN_PAR, 0)

        def WHERE_(self):
            return self.getToken(SQLiteParser.WHERE_, 0)

        def expr(self):
            return self.getTypedRuleContext(SQLiteParser.ExprContext,0)


        def CLOSE_PAR(self):
            return self.getToken(SQLiteParser.CLOSE_PAR, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_filter_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilter_clause" ):
                listener.enterFilter_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilter_clause" ):
                listener.exitFilter_clause(self)




    def filter_clause(self):

        localctx = SQLiteParser.Filter_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_filter_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 722
            self.match(SQLiteParser.FILTER_)
            self.state = 723
            self.match(SQLiteParser.OPEN_PAR)
            self.state = 724
            self.match(SQLiteParser.WHERE_)
            self.state = 725
            self.expr(0)
            self.state = 726
            self.match(SQLiteParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Over_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER_(self):
            return self.getToken(SQLiteParser.OVER_, 0)

        def window_name(self):
            return self.getTypedRuleContext(SQLiteParser.Window_nameContext,0)


        def OPEN_PAR(self):
            return self.getToken(SQLiteParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(SQLiteParser.CLOSE_PAR, 0)

        def base_window_name(self):
            return self.getTypedRuleContext(SQLiteParser.Base_window_nameContext,0)


        def PARTITION_(self):
            return self.getToken(SQLiteParser.PARTITION_, 0)

        def BY_(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.BY_)
            else:
                return self.getToken(SQLiteParser.BY_, i)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.ExprContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.ExprContext,i)


        def ORDER_(self):
            return self.getToken(SQLiteParser.ORDER_, 0)

        def ordering_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Ordering_termContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Ordering_termContext,i)


        def frame_spec(self):
            return self.getTypedRuleContext(SQLiteParser.Frame_specContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def getRuleIndex(self):
            return SQLiteParser.RULE_over_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOver_clause" ):
                listener.enterOver_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOver_clause" ):
                listener.exitOver_clause(self)




    def over_clause(self):

        localctx = SQLiteParser.Over_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_over_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 728
            self.match(SQLiteParser.OVER_)
            self.state = 762
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.state = 729
                self.window_name()
                pass

            elif la_ == 2:
                self.state = 730
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 732
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
                if la_ == 1:
                    self.state = 731
                    self.base_window_name()


                self.state = 744
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==155:
                    self.state = 734
                    self.match(SQLiteParser.PARTITION_)
                    self.state = 735
                    self.match(SQLiteParser.BY_)
                    self.state = 736
                    self.expr(0)
                    self.state = 741
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==5:
                        self.state = 737
                        self.match(SQLiteParser.COMMA)
                        self.state = 738
                        self.expr(0)
                        self.state = 743
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 756
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==110:
                    self.state = 746
                    self.match(SQLiteParser.ORDER_)
                    self.state = 747
                    self.match(SQLiteParser.BY_)
                    self.state = 748
                    self.ordering_term()
                    self.state = 753
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==5:
                        self.state = 749
                        self.match(SQLiteParser.COMMA)
                        self.state = 750
                        self.ordering_term()
                        self.state = 755
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 759
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & 2251799880794113) != 0:
                    self.state = 758
                    self.frame_spec()


                self.state = 761
                self.match(SQLiteParser.CLOSE_PAR)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Frame_specContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def frame_clause(self):
            return self.getTypedRuleContext(SQLiteParser.Frame_clauseContext,0)


        def EXCLUDE_(self):
            return self.getToken(SQLiteParser.EXCLUDE_, 0)

        def CURRENT_(self):
            return self.getToken(SQLiteParser.CURRENT_, 0)

        def ROW_(self):
            return self.getToken(SQLiteParser.ROW_, 0)

        def GROUP_(self):
            return self.getToken(SQLiteParser.GROUP_, 0)

        def TIES_(self):
            return self.getToken(SQLiteParser.TIES_, 0)

        def NO_(self):
            return self.getToken(SQLiteParser.NO_, 0)

        def OTHERS_(self):
            return self.getToken(SQLiteParser.OTHERS_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_frame_spec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrame_spec" ):
                listener.enterFrame_spec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrame_spec" ):
                listener.exitFrame_spec(self)




    def frame_spec(self):

        localctx = SQLiteParser.Frame_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_frame_spec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 764
            self.frame_clause()
            self.state = 772
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [182]:
                self.state = 765
                self.match(SQLiteParser.EXCLUDE_)

                self.state = 766
                self.match(SQLiteParser.NO_)
                self.state = 767
                self.match(SQLiteParser.OTHERS_)
                pass
            elif token in [159]:
                self.state = 768
                self.match(SQLiteParser.CURRENT_)
                self.state = 769
                self.match(SQLiteParser.ROW_)
                pass
            elif token in [78]:
                self.state = 770
                self.match(SQLiteParser.GROUP_)
                pass
            elif token in [183]:
                self.state = 771
                self.match(SQLiteParser.TIES_)
                pass
            elif token in [4]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Frame_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANGE_(self):
            return self.getToken(SQLiteParser.RANGE_, 0)

        def ROWS_(self):
            return self.getToken(SQLiteParser.ROWS_, 0)

        def GROUPS_(self):
            return self.getToken(SQLiteParser.GROUPS_, 0)

        def frame_single(self):
            return self.getTypedRuleContext(SQLiteParser.Frame_singleContext,0)


        def BETWEEN_(self):
            return self.getToken(SQLiteParser.BETWEEN_, 0)

        def frame_left(self):
            return self.getTypedRuleContext(SQLiteParser.Frame_leftContext,0)


        def AND_(self):
            return self.getToken(SQLiteParser.AND_, 0)

        def frame_right(self):
            return self.getTypedRuleContext(SQLiteParser.Frame_rightContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_frame_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrame_clause" ):
                listener.enterFrame_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrame_clause" ):
                listener.exitFrame_clause(self)




    def frame_clause(self):

        localctx = SQLiteParser.Frame_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_frame_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 774
            _la = self._input.LA(1)
            if not((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & 2251799880794113) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 781
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                self.state = 775
                self.frame_single()
                pass

            elif la_ == 2:
                self.state = 776
                self.match(SQLiteParser.BETWEEN_)
                self.state = 777
                self.frame_left()
                self.state = 778
                self.match(SQLiteParser.AND_)
                self.state = 779
                self.frame_right()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simple_function_invocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_func(self):
            return self.getTypedRuleContext(SQLiteParser.Simple_funcContext,0)


        def OPEN_PAR(self):
            return self.getToken(SQLiteParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(SQLiteParser.CLOSE_PAR, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.ExprContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.ExprContext,i)


        def STAR(self):
            return self.getToken(SQLiteParser.STAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def getRuleIndex(self):
            return SQLiteParser.RULE_simple_function_invocation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimple_function_invocation" ):
                listener.enterSimple_function_invocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimple_function_invocation" ):
                listener.exitSimple_function_invocation(self)




    def simple_function_invocation(self):

        localctx = SQLiteParser.Simple_function_invocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_simple_function_invocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 783
            self.simple_func()
            self.state = 784
            self.match(SQLiteParser.OPEN_PAR)
            self.state = 794
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 8, 9, 10, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 187, 188, 189, 190, 191]:
                self.state = 785
                self.expr(0)
                self.state = 790
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==5:
                    self.state = 786
                    self.match(SQLiteParser.COMMA)
                    self.state = 787
                    self.expr(0)
                    self.state = 792
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [7]:
                self.state = 793
                self.match(SQLiteParser.STAR)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 796
            self.match(SQLiteParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Aggregate_function_invocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aggregate_func(self):
            return self.getTypedRuleContext(SQLiteParser.Aggregate_funcContext,0)


        def OPEN_PAR(self):
            return self.getToken(SQLiteParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(SQLiteParser.CLOSE_PAR, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.ExprContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.ExprContext,i)


        def STAR(self):
            return self.getToken(SQLiteParser.STAR, 0)

        def filter_clause(self):
            return self.getTypedRuleContext(SQLiteParser.Filter_clauseContext,0)


        def DISTINCT_(self):
            return self.getToken(SQLiteParser.DISTINCT_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def getRuleIndex(self):
            return SQLiteParser.RULE_aggregate_function_invocation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregate_function_invocation" ):
                listener.enterAggregate_function_invocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregate_function_invocation" ):
                listener.exitAggregate_function_invocation(self)




    def aggregate_function_invocation(self):

        localctx = SQLiteParser.Aggregate_function_invocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_aggregate_function_invocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 798
            self.aggregate_func()
            self.state = 799
            self.match(SQLiteParser.OPEN_PAR)
            self.state = 812
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 8, 9, 10, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 187, 188, 189, 190, 191]:
                self.state = 801
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,106,self._ctx)
                if la_ == 1:
                    self.state = 800
                    self.match(SQLiteParser.DISTINCT_)


                self.state = 803
                self.expr(0)
                self.state = 808
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==5:
                    self.state = 804
                    self.match(SQLiteParser.COMMA)
                    self.state = 805
                    self.expr(0)
                    self.state = 810
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [7]:
                self.state = 811
                self.match(SQLiteParser.STAR)
                pass
            elif token in [4]:
                pass
            else:
                pass
            self.state = 814
            self.match(SQLiteParser.CLOSE_PAR)
            self.state = 816
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==180:
                self.state = 815
                self.filter_clause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Common_table_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH_(self):
            return self.getToken(SQLiteParser.WITH_, 0)

        def common_table_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Common_table_expressionContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Common_table_expressionContext,i)


        def RECURSIVE_(self):
            return self.getToken(SQLiteParser.RECURSIVE_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def getRuleIndex(self):
            return SQLiteParser.RULE_common_table_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommon_table_stmt" ):
                listener.enterCommon_table_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommon_table_stmt" ):
                listener.exitCommon_table_stmt(self)




    def common_table_stmt(self):

        localctx = SQLiteParser.Common_table_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_common_table_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 818
            self.match(SQLiteParser.WITH_)
            self.state = 820
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,110,self._ctx)
            if la_ == 1:
                self.state = 819
                self.match(SQLiteParser.RECURSIVE_)


            self.state = 822
            self.common_table_expression()
            self.state = 827
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 823
                self.match(SQLiteParser.COMMA)
                self.state = 824
                self.common_table_expression()
                self.state = 829
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Order_by_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER_BY_(self):
            return self.getToken(SQLiteParser.ORDER_BY_, 0)

        def ordering_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Ordering_termContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Ordering_termContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def getRuleIndex(self):
            return SQLiteParser.RULE_order_by_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder_by_stmt" ):
                listener.enterOrder_by_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder_by_stmt" ):
                listener.exitOrder_by_stmt(self)




    def order_by_stmt(self):

        localctx = SQLiteParser.Order_by_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_order_by_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 830
            self.match(SQLiteParser.ORDER_BY_)
            self.state = 831
            self.ordering_term()
            self.state = 836
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 832
                self.match(SQLiteParser.COMMA)
                self.state = 833
                self.ordering_term()
                self.state = 838
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Limit_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIMIT_(self):
            return self.getToken(SQLiteParser.LIMIT_, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.ExprContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.ExprContext,i)


        def OFFSET_(self):
            return self.getToken(SQLiteParser.OFFSET_, 0)

        def COMMA(self):
            return self.getToken(SQLiteParser.COMMA, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_limit_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimit_stmt" ):
                listener.enterLimit_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimit_stmt" ):
                listener.exitLimit_stmt(self)




    def limit_stmt(self):

        localctx = SQLiteParser.Limit_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_limit_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 839
            self.match(SQLiteParser.LIMIT_)
            self.state = 840
            self.expr(0)
            self.state = 843
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==5 or _la==107:
                self.state = 841
                _la = self._input.LA(1)
                if not(_la==5 or _la==107):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 842
                self.expr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ordering_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(SQLiteParser.ExprContext,0)


        def COLLATE_(self):
            return self.getToken(SQLiteParser.COLLATE_, 0)

        def collation_name(self):
            return self.getTypedRuleContext(SQLiteParser.Collation_nameContext,0)


        def asc_desc(self):
            return self.getTypedRuleContext(SQLiteParser.Asc_descContext,0)


        def NULLS_(self):
            return self.getToken(SQLiteParser.NULLS_, 0)

        def FIRST_(self):
            return self.getToken(SQLiteParser.FIRST_, 0)

        def LAST_(self):
            return self.getToken(SQLiteParser.LAST_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_ordering_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrdering_term" ):
                listener.enterOrdering_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrdering_term" ):
                listener.exitOrdering_term(self)




    def ordering_term(self):

        localctx = SQLiteParser.Ordering_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_ordering_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 845
            self.expr(0)
            self.state = 848
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 846
                self.match(SQLiteParser.COLLATE_)
                self.state = 847
                self.collation_name()


            self.state = 851
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34 or _la==60:
                self.state = 850
                self.asc_desc()


            self.state = 855
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==177:
                self.state = 853
                self.match(SQLiteParser.NULLS_)
                self.state = 854
                _la = self._input.LA(1)
                if not(_la==178 or _la==179):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Asc_descContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASC_(self):
            return self.getToken(SQLiteParser.ASC_, 0)

        def DESC_(self):
            return self.getToken(SQLiteParser.DESC_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_asc_desc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAsc_desc" ):
                listener.enterAsc_desc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAsc_desc" ):
                listener.exitAsc_desc(self)




    def asc_desc(self):

        localctx = SQLiteParser.Asc_descContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_asc_desc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 857
            _la = self._input.LA(1)
            if not(_la==34 or _la==60):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Frame_leftContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(SQLiteParser.ExprContext,0)


        def PRECEDING_(self):
            return self.getToken(SQLiteParser.PRECEDING_, 0)

        def FOLLOWING_(self):
            return self.getToken(SQLiteParser.FOLLOWING_, 0)

        def CURRENT_(self):
            return self.getToken(SQLiteParser.CURRENT_, 0)

        def ROW_(self):
            return self.getToken(SQLiteParser.ROW_, 0)

        def UNBOUNDED_(self):
            return self.getToken(SQLiteParser.UNBOUNDED_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_frame_left

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrame_left" ):
                listener.enterFrame_left(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrame_left" ):
                listener.exitFrame_left(self)




    def frame_left(self):

        localctx = SQLiteParser.Frame_leftContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_frame_left)
        try:
            self.state = 869
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,117,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 859
                self.expr(0)
                self.state = 860
                self.match(SQLiteParser.PRECEDING_)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 862
                self.expr(0)
                self.state = 863
                self.match(SQLiteParser.FOLLOWING_)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 865
                self.match(SQLiteParser.CURRENT_)
                self.state = 866
                self.match(SQLiteParser.ROW_)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 867
                self.match(SQLiteParser.UNBOUNDED_)
                self.state = 868
                self.match(SQLiteParser.PRECEDING_)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Frame_rightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(SQLiteParser.ExprContext,0)


        def PRECEDING_(self):
            return self.getToken(SQLiteParser.PRECEDING_, 0)

        def FOLLOWING_(self):
            return self.getToken(SQLiteParser.FOLLOWING_, 0)

        def CURRENT_(self):
            return self.getToken(SQLiteParser.CURRENT_, 0)

        def ROW_(self):
            return self.getToken(SQLiteParser.ROW_, 0)

        def UNBOUNDED_(self):
            return self.getToken(SQLiteParser.UNBOUNDED_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_frame_right

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrame_right" ):
                listener.enterFrame_right(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrame_right" ):
                listener.exitFrame_right(self)




    def frame_right(self):

        localctx = SQLiteParser.Frame_rightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_frame_right)
        try:
            self.state = 881
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 871
                self.expr(0)
                self.state = 872
                self.match(SQLiteParser.PRECEDING_)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 874
                self.expr(0)
                self.state = 875
                self.match(SQLiteParser.FOLLOWING_)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 877
                self.match(SQLiteParser.CURRENT_)
                self.state = 878
                self.match(SQLiteParser.ROW_)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 879
                self.match(SQLiteParser.UNBOUNDED_)
                self.state = 880
                self.match(SQLiteParser.FOLLOWING_)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Frame_singleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(SQLiteParser.ExprContext,0)


        def PRECEDING_(self):
            return self.getToken(SQLiteParser.PRECEDING_, 0)

        def UNBOUNDED_(self):
            return self.getToken(SQLiteParser.UNBOUNDED_, 0)

        def CURRENT_(self):
            return self.getToken(SQLiteParser.CURRENT_, 0)

        def ROW_(self):
            return self.getToken(SQLiteParser.ROW_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_frame_single

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrame_single" ):
                listener.enterFrame_single(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrame_single" ):
                listener.exitFrame_single(self)




    def frame_single(self):

        localctx = SQLiteParser.Frame_singleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_frame_single)
        try:
            self.state = 890
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,119,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 883
                self.expr(0)
                self.state = 884
                self.match(SQLiteParser.PRECEDING_)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 886
                self.match(SQLiteParser.UNBOUNDED_)
                self.state = 887
                self.match(SQLiteParser.PRECEDING_)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 888
                self.match(SQLiteParser.CURRENT_)
                self.state = 889
                self.match(SQLiteParser.ROW_)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OffsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(SQLiteParser.COMMA, 0)

        def signed_number(self):
            return self.getTypedRuleContext(SQLiteParser.Signed_numberContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_offset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset" ):
                listener.enterOffset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset" ):
                listener.exitOffset(self)




    def offset(self):

        localctx = SQLiteParser.OffsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_offset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 892
            self.match(SQLiteParser.COMMA)
            self.state = 893
            self.signed_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Default_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(SQLiteParser.COMMA, 0)

        def signed_number(self):
            return self.getTypedRuleContext(SQLiteParser.Signed_numberContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_default_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault_value" ):
                listener.enterDefault_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault_value" ):
                listener.exitDefault_value(self)




    def default_value(self):

        localctx = SQLiteParser.Default_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_default_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 895
            self.match(SQLiteParser.COMMA)
            self.state = 896
            self.signed_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Partition_byContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARTITION_(self):
            return self.getToken(SQLiteParser.PARTITION_, 0)

        def BY_(self):
            return self.getToken(SQLiteParser.BY_, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.ExprContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.ExprContext,i)


        def getRuleIndex(self):
            return SQLiteParser.RULE_partition_by

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartition_by" ):
                listener.enterPartition_by(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartition_by" ):
                listener.exitPartition_by(self)




    def partition_by(self):

        localctx = SQLiteParser.Partition_byContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_partition_by)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 898
            self.match(SQLiteParser.PARTITION_)
            self.state = 899
            self.match(SQLiteParser.BY_)
            self.state = 901 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 900
                self.expr(0)
                self.state = 903 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((_la) & ~0x3f) == 0 and ((1 << _la) & -33552632) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & -4611826755915776001) != 0 or (((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -540431955284459521) != 0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Order_by_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER_(self):
            return self.getToken(SQLiteParser.ORDER_, 0)

        def BY_(self):
            return self.getToken(SQLiteParser.BY_, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.ExprContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.ExprContext,i)


        def getRuleIndex(self):
            return SQLiteParser.RULE_order_by_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder_by_expr" ):
                listener.enterOrder_by_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder_by_expr" ):
                listener.exitOrder_by_expr(self)




    def order_by_expr(self):

        localctx = SQLiteParser.Order_by_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_order_by_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 905
            self.match(SQLiteParser.ORDER_)
            self.state = 906
            self.match(SQLiteParser.BY_)
            self.state = 908 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 907
                self.expr(0)
                self.state = 910 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((_la) & ~0x3f) == 0 and ((1 << _la) & -33552632) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & -4611826755915776001) != 0 or (((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -540431955284459521) != 0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Order_by_expr_asc_descContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER_(self):
            return self.getToken(SQLiteParser.ORDER_, 0)

        def BY_(self):
            return self.getToken(SQLiteParser.BY_, 0)

        def expr_asc_desc(self):
            return self.getTypedRuleContext(SQLiteParser.Expr_asc_descContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_order_by_expr_asc_desc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder_by_expr_asc_desc" ):
                listener.enterOrder_by_expr_asc_desc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder_by_expr_asc_desc" ):
                listener.exitOrder_by_expr_asc_desc(self)




    def order_by_expr_asc_desc(self):

        localctx = SQLiteParser.Order_by_expr_asc_descContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_order_by_expr_asc_desc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 912
            self.match(SQLiteParser.ORDER_)
            self.state = 913
            self.match(SQLiteParser.BY_)
            self.state = 914
            self.expr_asc_desc()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Expr_asc_descContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.ExprContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.ExprContext,i)


        def asc_desc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SQLiteParser.Asc_descContext)
            else:
                return self.getTypedRuleContext(SQLiteParser.Asc_descContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SQLiteParser.COMMA)
            else:
                return self.getToken(SQLiteParser.COMMA, i)

        def getRuleIndex(self):
            return SQLiteParser.RULE_expr_asc_desc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_asc_desc" ):
                listener.enterExpr_asc_desc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_asc_desc" ):
                listener.exitExpr_asc_desc(self)




    def expr_asc_desc(self):

        localctx = SQLiteParser.Expr_asc_descContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_expr_asc_desc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 916
            self.expr(0)
            self.state = 918
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34 or _la==60:
                self.state = 917
                self.asc_desc()


            self.state = 927
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 920
                self.match(SQLiteParser.COMMA)
                self.state = 921
                self.expr(0)
                self.state = 923
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==34 or _la==60:
                    self.state = 922
                    self.asc_desc()


                self.state = 929
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Initial_selectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Select_stmtContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_initial_select

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitial_select" ):
                listener.enterInitial_select(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitial_select" ):
                listener.exitInitial_select(self)




    def initial_select(self):

        localctx = SQLiteParser.Initial_selectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_initial_select)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 930
            self.select_stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Recursive_selectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_stmt(self):
            return self.getTypedRuleContext(SQLiteParser.Select_stmtContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_recursive_select

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRecursive_select" ):
                listener.enterRecursive_select(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRecursive_select" ):
                listener.exitRecursive_select(self)




    def recursive_select(self):

        localctx = SQLiteParser.Recursive_selectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_recursive_select)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 932
            self.select_stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unary_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(SQLiteParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(SQLiteParser.PLUS, 0)

        def TILDE(self):
            return self.getToken(SQLiteParser.TILDE, 0)

        def NOT_(self):
            return self.getToken(SQLiteParser.NOT_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_unary_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_operator" ):
                listener.enterUnary_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_operator" ):
                listener.exitUnary_operator(self)




    def unary_operator(self):

        localctx = SQLiteParser.Unary_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_unary_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 934
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 1792) != 0 or _la==103):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Error_messageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(SQLiteParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_error_message

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterError_message" ):
                listener.enterError_message(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitError_message" ):
                listener.exitError_message(self)




    def error_message(self):

        localctx = SQLiteParser.Error_messageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_error_message)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 936
            self.match(SQLiteParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_aliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(SQLiteParser.IDENTIFIER, 0)

        def STRING_LITERAL(self):
            return self.getToken(SQLiteParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_column_alias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_alias" ):
                listener.enterColumn_alias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_alias" ):
                listener.exitColumn_alias(self)




    def column_alias(self):

        localctx = SQLiteParser.Column_aliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_column_alias)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 938
            _la = self._input.LA(1)
            if not(_la==187 or _la==190):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ABORT_(self):
            return self.getToken(SQLiteParser.ABORT_, 0)

        def ACTION_(self):
            return self.getToken(SQLiteParser.ACTION_, 0)

        def ADD_(self):
            return self.getToken(SQLiteParser.ADD_, 0)

        def AFTER_(self):
            return self.getToken(SQLiteParser.AFTER_, 0)

        def ALL_(self):
            return self.getToken(SQLiteParser.ALL_, 0)

        def ALTER_(self):
            return self.getToken(SQLiteParser.ALTER_, 0)

        def ANALYZE_(self):
            return self.getToken(SQLiteParser.ANALYZE_, 0)

        def AND_(self):
            return self.getToken(SQLiteParser.AND_, 0)

        def AS_(self):
            return self.getToken(SQLiteParser.AS_, 0)

        def ASC_(self):
            return self.getToken(SQLiteParser.ASC_, 0)

        def ATTACH_(self):
            return self.getToken(SQLiteParser.ATTACH_, 0)

        def AUTOINCREMENT_(self):
            return self.getToken(SQLiteParser.AUTOINCREMENT_, 0)

        def BEFORE_(self):
            return self.getToken(SQLiteParser.BEFORE_, 0)

        def BEGIN_(self):
            return self.getToken(SQLiteParser.BEGIN_, 0)

        def BETWEEN_(self):
            return self.getToken(SQLiteParser.BETWEEN_, 0)

        def BY_(self):
            return self.getToken(SQLiteParser.BY_, 0)

        def CASCADE_(self):
            return self.getToken(SQLiteParser.CASCADE_, 0)

        def CASE_(self):
            return self.getToken(SQLiteParser.CASE_, 0)

        def CAST_(self):
            return self.getToken(SQLiteParser.CAST_, 0)

        def CHECK_(self):
            return self.getToken(SQLiteParser.CHECK_, 0)

        def COLLATE_(self):
            return self.getToken(SQLiteParser.COLLATE_, 0)

        def COLUMN_(self):
            return self.getToken(SQLiteParser.COLUMN_, 0)

        def COMMIT_(self):
            return self.getToken(SQLiteParser.COMMIT_, 0)

        def CONFLICT_(self):
            return self.getToken(SQLiteParser.CONFLICT_, 0)

        def CONSTRAINT_(self):
            return self.getToken(SQLiteParser.CONSTRAINT_, 0)

        def CREATE_(self):
            return self.getToken(SQLiteParser.CREATE_, 0)

        def CROSS_(self):
            return self.getToken(SQLiteParser.CROSS_, 0)

        def CURRENT_DATE_(self):
            return self.getToken(SQLiteParser.CURRENT_DATE_, 0)

        def CURRENT_TIME_(self):
            return self.getToken(SQLiteParser.CURRENT_TIME_, 0)

        def CURRENT_TIMESTAMP_(self):
            return self.getToken(SQLiteParser.CURRENT_TIMESTAMP_, 0)

        def DATABASE_(self):
            return self.getToken(SQLiteParser.DATABASE_, 0)

        def DEFAULT_(self):
            return self.getToken(SQLiteParser.DEFAULT_, 0)

        def DEFERRABLE_(self):
            return self.getToken(SQLiteParser.DEFERRABLE_, 0)

        def DEFERRED_(self):
            return self.getToken(SQLiteParser.DEFERRED_, 0)

        def DELETE_(self):
            return self.getToken(SQLiteParser.DELETE_, 0)

        def DESC_(self):
            return self.getToken(SQLiteParser.DESC_, 0)

        def DETACH_(self):
            return self.getToken(SQLiteParser.DETACH_, 0)

        def DISTINCT_(self):
            return self.getToken(SQLiteParser.DISTINCT_, 0)

        def DROP_(self):
            return self.getToken(SQLiteParser.DROP_, 0)

        def EACH_(self):
            return self.getToken(SQLiteParser.EACH_, 0)

        def ELSE_(self):
            return self.getToken(SQLiteParser.ELSE_, 0)

        def END_(self):
            return self.getToken(SQLiteParser.END_, 0)

        def ESCAPE_(self):
            return self.getToken(SQLiteParser.ESCAPE_, 0)

        def EXCEPT_(self):
            return self.getToken(SQLiteParser.EXCEPT_, 0)

        def EXCLUSIVE_(self):
            return self.getToken(SQLiteParser.EXCLUSIVE_, 0)

        def EXISTS_(self):
            return self.getToken(SQLiteParser.EXISTS_, 0)

        def EXPLAIN_(self):
            return self.getToken(SQLiteParser.EXPLAIN_, 0)

        def FAIL_(self):
            return self.getToken(SQLiteParser.FAIL_, 0)

        def FOR_(self):
            return self.getToken(SQLiteParser.FOR_, 0)

        def FOREIGN_(self):
            return self.getToken(SQLiteParser.FOREIGN_, 0)

        def FROM_(self):
            return self.getToken(SQLiteParser.FROM_, 0)

        def FULL_(self):
            return self.getToken(SQLiteParser.FULL_, 0)

        def GLOB_(self):
            return self.getToken(SQLiteParser.GLOB_, 0)

        def GROUP_(self):
            return self.getToken(SQLiteParser.GROUP_, 0)

        def HAVING_(self):
            return self.getToken(SQLiteParser.HAVING_, 0)

        def IF_(self):
            return self.getToken(SQLiteParser.IF_, 0)

        def IGNORE_(self):
            return self.getToken(SQLiteParser.IGNORE_, 0)

        def IMMEDIATE_(self):
            return self.getToken(SQLiteParser.IMMEDIATE_, 0)

        def IN_(self):
            return self.getToken(SQLiteParser.IN_, 0)

        def INDEX_(self):
            return self.getToken(SQLiteParser.INDEX_, 0)

        def INDEXED_(self):
            return self.getToken(SQLiteParser.INDEXED_, 0)

        def INITIALLY_(self):
            return self.getToken(SQLiteParser.INITIALLY_, 0)

        def INNER_(self):
            return self.getToken(SQLiteParser.INNER_, 0)

        def INSERT_(self):
            return self.getToken(SQLiteParser.INSERT_, 0)

        def INSTEAD_(self):
            return self.getToken(SQLiteParser.INSTEAD_, 0)

        def INTERSECT_(self):
            return self.getToken(SQLiteParser.INTERSECT_, 0)

        def INTO_(self):
            return self.getToken(SQLiteParser.INTO_, 0)

        def IS_(self):
            return self.getToken(SQLiteParser.IS_, 0)

        def ISNULL_(self):
            return self.getToken(SQLiteParser.ISNULL_, 0)

        def JOIN_(self):
            return self.getToken(SQLiteParser.JOIN_, 0)

        def KEY_(self):
            return self.getToken(SQLiteParser.KEY_, 0)

        def LEFT_(self):
            return self.getToken(SQLiteParser.LEFT_, 0)

        def LIKE_(self):
            return self.getToken(SQLiteParser.LIKE_, 0)

        def LIMIT_(self):
            return self.getToken(SQLiteParser.LIMIT_, 0)

        def MATCH_(self):
            return self.getToken(SQLiteParser.MATCH_, 0)

        def NATURAL_(self):
            return self.getToken(SQLiteParser.NATURAL_, 0)

        def NO_(self):
            return self.getToken(SQLiteParser.NO_, 0)

        def NOT_(self):
            return self.getToken(SQLiteParser.NOT_, 0)

        def NOTNULL_(self):
            return self.getToken(SQLiteParser.NOTNULL_, 0)

        def NULL_(self):
            return self.getToken(SQLiteParser.NULL_, 0)

        def OF_(self):
            return self.getToken(SQLiteParser.OF_, 0)

        def OFFSET_(self):
            return self.getToken(SQLiteParser.OFFSET_, 0)

        def ON_(self):
            return self.getToken(SQLiteParser.ON_, 0)

        def OR_(self):
            return self.getToken(SQLiteParser.OR_, 0)

        def ORDER_(self):
            return self.getToken(SQLiteParser.ORDER_, 0)

        def OUTER_(self):
            return self.getToken(SQLiteParser.OUTER_, 0)

        def PLAN_(self):
            return self.getToken(SQLiteParser.PLAN_, 0)

        def PRAGMA_(self):
            return self.getToken(SQLiteParser.PRAGMA_, 0)

        def PRIMARY_(self):
            return self.getToken(SQLiteParser.PRIMARY_, 0)

        def QUERY_(self):
            return self.getToken(SQLiteParser.QUERY_, 0)

        def RAISE_(self):
            return self.getToken(SQLiteParser.RAISE_, 0)

        def RECURSIVE_(self):
            return self.getToken(SQLiteParser.RECURSIVE_, 0)

        def REFERENCES_(self):
            return self.getToken(SQLiteParser.REFERENCES_, 0)

        def REGEXP_(self):
            return self.getToken(SQLiteParser.REGEXP_, 0)

        def REINDEX_(self):
            return self.getToken(SQLiteParser.REINDEX_, 0)

        def RELEASE_(self):
            return self.getToken(SQLiteParser.RELEASE_, 0)

        def RENAME_(self):
            return self.getToken(SQLiteParser.RENAME_, 0)

        def REPLACE_(self):
            return self.getToken(SQLiteParser.REPLACE_, 0)

        def RESTRICT_(self):
            return self.getToken(SQLiteParser.RESTRICT_, 0)

        def RIGHT_(self):
            return self.getToken(SQLiteParser.RIGHT_, 0)

        def ROLLBACK_(self):
            return self.getToken(SQLiteParser.ROLLBACK_, 0)

        def ROW_(self):
            return self.getToken(SQLiteParser.ROW_, 0)

        def ROWS_(self):
            return self.getToken(SQLiteParser.ROWS_, 0)

        def SAVEPOINT_(self):
            return self.getToken(SQLiteParser.SAVEPOINT_, 0)

        def SELECT_(self):
            return self.getToken(SQLiteParser.SELECT_, 0)

        def SET_(self):
            return self.getToken(SQLiteParser.SET_, 0)

        def TABLE_(self):
            return self.getToken(SQLiteParser.TABLE_, 0)

        def TEMP_(self):
            return self.getToken(SQLiteParser.TEMP_, 0)

        def TEMPORARY_(self):
            return self.getToken(SQLiteParser.TEMPORARY_, 0)

        def THEN_(self):
            return self.getToken(SQLiteParser.THEN_, 0)

        def TO_(self):
            return self.getToken(SQLiteParser.TO_, 0)

        def TRANSACTION_(self):
            return self.getToken(SQLiteParser.TRANSACTION_, 0)

        def TRIGGER_(self):
            return self.getToken(SQLiteParser.TRIGGER_, 0)

        def UNION_(self):
            return self.getToken(SQLiteParser.UNION_, 0)

        def UNIQUE_(self):
            return self.getToken(SQLiteParser.UNIQUE_, 0)

        def UPDATE_(self):
            return self.getToken(SQLiteParser.UPDATE_, 0)

        def USING_(self):
            return self.getToken(SQLiteParser.USING_, 0)

        def VACUUM_(self):
            return self.getToken(SQLiteParser.VACUUM_, 0)

        def VALUES_(self):
            return self.getToken(SQLiteParser.VALUES_, 0)

        def VIEW_(self):
            return self.getToken(SQLiteParser.VIEW_, 0)

        def VIRTUAL_(self):
            return self.getToken(SQLiteParser.VIRTUAL_, 0)

        def WHEN_(self):
            return self.getToken(SQLiteParser.WHEN_, 0)

        def WHERE_(self):
            return self.getToken(SQLiteParser.WHERE_, 0)

        def WITH_(self):
            return self.getToken(SQLiteParser.WITH_, 0)

        def WITHOUT_(self):
            return self.getToken(SQLiteParser.WITHOUT_, 0)

        def FIRST_VALUE_(self):
            return self.getToken(SQLiteParser.FIRST_VALUE_, 0)

        def OVER_(self):
            return self.getToken(SQLiteParser.OVER_, 0)

        def PARTITION_(self):
            return self.getToken(SQLiteParser.PARTITION_, 0)

        def RANGE_(self):
            return self.getToken(SQLiteParser.RANGE_, 0)

        def PRECEDING_(self):
            return self.getToken(SQLiteParser.PRECEDING_, 0)

        def UNBOUNDED_(self):
            return self.getToken(SQLiteParser.UNBOUNDED_, 0)

        def CURRENT_(self):
            return self.getToken(SQLiteParser.CURRENT_, 0)

        def FOLLOWING_(self):
            return self.getToken(SQLiteParser.FOLLOWING_, 0)

        def CUME_DIST_(self):
            return self.getToken(SQLiteParser.CUME_DIST_, 0)

        def DENSE_RANK_(self):
            return self.getToken(SQLiteParser.DENSE_RANK_, 0)

        def LAG_(self):
            return self.getToken(SQLiteParser.LAG_, 0)

        def LAST_VALUE_(self):
            return self.getToken(SQLiteParser.LAST_VALUE_, 0)

        def LEAD_(self):
            return self.getToken(SQLiteParser.LEAD_, 0)

        def NTH_VALUE_(self):
            return self.getToken(SQLiteParser.NTH_VALUE_, 0)

        def NTILE_(self):
            return self.getToken(SQLiteParser.NTILE_, 0)

        def PERCENT_RANK_(self):
            return self.getToken(SQLiteParser.PERCENT_RANK_, 0)

        def RANK_(self):
            return self.getToken(SQLiteParser.RANK_, 0)

        def ROW_NUMBER_(self):
            return self.getToken(SQLiteParser.ROW_NUMBER_, 0)

        def GENERATED_(self):
            return self.getToken(SQLiteParser.GENERATED_, 0)

        def ALWAYS_(self):
            return self.getToken(SQLiteParser.ALWAYS_, 0)

        def STORED_(self):
            return self.getToken(SQLiteParser.STORED_, 0)

        def TRUE_(self):
            return self.getToken(SQLiteParser.TRUE_, 0)

        def FALSE_(self):
            return self.getToken(SQLiteParser.FALSE_, 0)

        def WINDOW_(self):
            return self.getToken(SQLiteParser.WINDOW_, 0)

        def NULLS_(self):
            return self.getToken(SQLiteParser.NULLS_, 0)

        def FIRST_(self):
            return self.getToken(SQLiteParser.FIRST_, 0)

        def LAST_(self):
            return self.getToken(SQLiteParser.LAST_, 0)

        def FILTER_(self):
            return self.getToken(SQLiteParser.FILTER_, 0)

        def GROUPS_(self):
            return self.getToken(SQLiteParser.GROUPS_, 0)

        def EXCLUDE_(self):
            return self.getToken(SQLiteParser.EXCLUDE_, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_keyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyword" ):
                listener.enterKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyword" ):
                listener.exitKeyword(self)




    def keyword(self):

        localctx = SQLiteParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_keyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 940
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & -33554432) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & -4611826755915776001) != 0 or (((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & 36028797018963967) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)




    def name(self):

        localctx = SQLiteParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 942
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_function_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_name" ):
                listener.enterFunction_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_name" ):
                listener.exitFunction_name(self)




    def function_name(self):

        localctx = SQLiteParser.Function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_function_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 944
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schema_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_schema_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchema_name" ):
                listener.enterSchema_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchema_name" ):
                listener.exitSchema_name(self)




    def schema_name(self):

        localctx = SQLiteParser.Schema_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_schema_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 946
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_table_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_name" ):
                listener.enterTable_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_name" ):
                listener.exitTable_name(self)




    def table_name(self):

        localctx = SQLiteParser.Table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_table_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 948
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_or_index_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_table_or_index_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_or_index_name" ):
                listener.enterTable_or_index_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_or_index_name" ):
                listener.exitTable_or_index_name(self)




    def table_or_index_name(self):

        localctx = SQLiteParser.Table_or_index_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_table_or_index_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 950
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class New_table_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_new_table_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNew_table_name" ):
                listener.enterNew_table_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNew_table_name" ):
                listener.exitNew_table_name(self)




    def new_table_name(self):

        localctx = SQLiteParser.New_table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_new_table_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 952
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_column_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_name" ):
                listener.enterColumn_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_name" ):
                listener.exitColumn_name(self)




    def column_name(self):

        localctx = SQLiteParser.Column_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_column_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 954
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Collation_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_collation_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollation_name" ):
                listener.enterCollation_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollation_name" ):
                listener.exitCollation_name(self)




    def collation_name(self):

        localctx = SQLiteParser.Collation_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_collation_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 956
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Foreign_tableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_foreign_table

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForeign_table" ):
                listener.enterForeign_table(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForeign_table" ):
                listener.exitForeign_table(self)




    def foreign_table(self):

        localctx = SQLiteParser.Foreign_tableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_foreign_table)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 958
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_index_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_name" ):
                listener.enterIndex_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_name" ):
                listener.exitIndex_name(self)




    def index_name(self):

        localctx = SQLiteParser.Index_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_index_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 960
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Trigger_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_trigger_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrigger_name" ):
                listener.enterTrigger_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrigger_name" ):
                listener.exitTrigger_name(self)




    def trigger_name(self):

        localctx = SQLiteParser.Trigger_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_trigger_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 962
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class View_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_view_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterView_name" ):
                listener.enterView_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitView_name" ):
                listener.exitView_name(self)




    def view_name(self):

        localctx = SQLiteParser.View_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_view_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 964
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Module_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_module_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModule_name" ):
                listener.enterModule_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModule_name" ):
                listener.exitModule_name(self)




    def module_name(self):

        localctx = SQLiteParser.Module_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_module_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 966
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pragma_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_pragma_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPragma_name" ):
                listener.enterPragma_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPragma_name" ):
                listener.exitPragma_name(self)




    def pragma_name(self):

        localctx = SQLiteParser.Pragma_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_pragma_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 968
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Savepoint_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_savepoint_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSavepoint_name" ):
                listener.enterSavepoint_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSavepoint_name" ):
                listener.exitSavepoint_name(self)




    def savepoint_name(self):

        localctx = SQLiteParser.Savepoint_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_savepoint_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 970
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_aliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_table_alias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_alias" ):
                listener.enterTable_alias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_alias" ):
                listener.exitTable_alias(self)




    def table_alias(self):

        localctx = SQLiteParser.Table_aliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_table_alias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 972
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Transaction_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_transaction_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTransaction_name" ):
                listener.enterTransaction_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTransaction_name" ):
                listener.exitTransaction_name(self)




    def transaction_name(self):

        localctx = SQLiteParser.Transaction_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_transaction_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 974
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Window_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_window_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindow_name" ):
                listener.enterWindow_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindow_name" ):
                listener.exitWindow_name(self)




    def window_name(self):

        localctx = SQLiteParser.Window_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_window_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 976
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_alias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlias" ):
                listener.enterAlias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlias" ):
                listener.exitAlias(self)




    def alias(self):

        localctx = SQLiteParser.AliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_alias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 978
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilenameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_filename

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilename" ):
                listener.enterFilename(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilename" ):
                listener.exitFilename(self)




    def filename(self):

        localctx = SQLiteParser.FilenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_filename)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 980
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Base_window_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_base_window_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBase_window_name" ):
                listener.enterBase_window_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBase_window_name" ):
                listener.exitBase_window_name(self)




    def base_window_name(self):

        localctx = SQLiteParser.Base_window_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_base_window_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 982
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simple_funcContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_simple_func

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimple_func" ):
                listener.enterSimple_func(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimple_func" ):
                listener.exitSimple_func(self)




    def simple_func(self):

        localctx = SQLiteParser.Simple_funcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_simple_func)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 984
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Aggregate_funcContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_aggregate_func

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregate_func" ):
                listener.enterAggregate_func(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregate_func" ):
                listener.exitAggregate_func(self)




    def aggregate_func(self):

        localctx = SQLiteParser.Aggregate_funcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_aggregate_func)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 986
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_function_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def getRuleIndex(self):
            return SQLiteParser.RULE_table_function_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_function_name" ):
                listener.enterTable_function_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_function_name" ):
                listener.exitTable_function_name(self)




    def table_function_name(self):

        localctx = SQLiteParser.Table_function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_table_function_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 988
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Any_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(SQLiteParser.IDENTIFIER, 0)

        def keyword(self):
            return self.getTypedRuleContext(SQLiteParser.KeywordContext,0)


        def STRING_LITERAL(self):
            return self.getToken(SQLiteParser.STRING_LITERAL, 0)

        def OPEN_PAR(self):
            return self.getToken(SQLiteParser.OPEN_PAR, 0)

        def any_name(self):
            return self.getTypedRuleContext(SQLiteParser.Any_nameContext,0)


        def CLOSE_PAR(self):
            return self.getToken(SQLiteParser.CLOSE_PAR, 0)

        def getRuleIndex(self):
            return SQLiteParser.RULE_any_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAny_name" ):
                listener.enterAny_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAny_name" ):
                listener.exitAny_name(self)




    def any_name(self):

        localctx = SQLiteParser.Any_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_any_name)
        try:
            self.state = 997
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [187]:
                self.enterOuterAlt(localctx, 1)
                self.state = 990
                self.match(SQLiteParser.IDENTIFIER)
                pass
            elif token in [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182]:
                self.enterOuterAlt(localctx, 2)
                self.state = 991
                self.keyword()
                pass
            elif token in [190]:
                self.enterOuterAlt(localctx, 3)
                self.state = 992
                self.match(SQLiteParser.STRING_LITERAL)
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 4)
                self.state = 993
                self.match(SQLiteParser.OPEN_PAR)
                self.state = 994
                self.any_name()
                self.state = 995
                self.match(SQLiteParser.CLOSE_PAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[6] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 19)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 18)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 4)
         




